.TH "inf2990" 3 "Mon Feb 15 2016" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
inf2990 \- INF2990
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBmodele\fP"
.br
.RI "\fIDéclarations avancées pour contenir un pointeur vers un modèle3D et son storage\&. \fP"
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBFacadeModele\fP"
.br
.RI "\fIClasse qui constitue une interface (une façade) sur l'ensemble du modèle et des classes qui le composent\&. \fP"
.ti -1c
.RI "class \fBArbreRendu\fP"
.br
.RI "\fIClasse d'arbre de rendu qui contient la racine de l'arbre de rendu avec les usines qui permettent d'ajouter des noeuds à cet arbre\&. \fP"
.ti -1c
.RI "class \fBArbreRenduINF2990\fP"
.br
.RI "\fIClasse qui représente l'arbre de rendu spécifique au projet de INF2990\&. \fP"
.ti -1c
.RI "class \fBNoeudAbstrait\fP"
.br
.RI "\fIClasse de base du patron composite utilisée pour créer l'arbre de rendu\&. \fP"
.ti -1c
.RI "class \fBNoeudComposite\fP"
.br
.RI "\fIImplantation d'un noeud du patron composite qui peut posséder des enfants\&. \fP"
.ti -1c
.RI "class \fBNoeudDepart\fP"
.br
.RI "\fIClasse qui représente le point départ du robot lors de la simulation\&. \fP"
.ti -1c
.RI "class \fBNoeudDuplication\fP"
.br
.RI "\fINoeud qui représente une duplication lors de l'utilisation de l'outil duplication\&. \fP"
.ti -1c
.RI "class \fBNoeudJonction\fP"
.br
.RI "\fINoeud de l'objet rendu servant à la liaison de segments de la ligne noire\&. \fP"
.ti -1c
.RI "class \fBNoeudLigne\fP"
.br
.RI "\fINoeud de l'objet englobant tous les segments et jonctions d'une ligne noire\&. \fP"
.ti -1c
.RI "class \fBNoeudMur\fP"
.br
.ti -1c
.RI "class \fBNoeudPoteau\fP"
.br
.RI "\fINoeud des obstacles au robot sous forme de poteaux\&. \fP"
.ti -1c
.RI "class \fBNoeudRobot\fP"
.br
.RI "\fIClasse qui représente le robot du premier projet intégrateur\&. \fP"
.ti -1c
.RI "class \fBNoeudSegment\fP"
.br
.RI "\fIChaque noeud de ce type représente un des segments qui composent une ligne noire\&. Celles-ci se situent habituellement sous un objet de type \fBNoeudLigne\fP\&. \fP"
.ti -1c
.RI "class \fBNoeudTable\fP"
.br
.RI "\fINoeud représentant la table, c'est à dire la zone de simulation\&. \fP"
.ti -1c
.RI "class \fBUsineAbstraite\fP"
.br
.RI "\fIClasse de base abstraite des usines qui seront utilisées pour créer les différents noeuds de l'arbre de rendu\&. \fP"
.ti -1c
.RI "class \fBUsineNoeud< Noeud >\fP"
.br
.RI "\fIClass template permettant de créer un type de noeud concret pour l'arbre de rendu\&. \fP"
.ti -1c
.RI "class \fBConfigScene\fP"
.br
.RI "\fILes variables de configuration de la classe CScene\&. C'est une classe singleton\&. \fP"
.ti -1c
.RI "class \fBEtatAbstrait\fP"
.br
.RI "\fIClasse de base pour chaque état\&. \fP"
.ti -1c
.RI "class \fBEtatCreationLigne\fP"
.br
.RI "\fIÉtat représentant la creation d'une ligne\&. \fP"
.ti -1c
.RI "class \fBEtatCreationMur\fP"
.br
.RI "\fIÉtat représentant la creation d'un mur\&. \fP"
.ti -1c
.RI "class \fBEtatCreationPoteau\fP"
.br
.RI "\fIÉtat représentant la creation d'un poteau\&. \fP"
.ti -1c
.RI "class \fBEtatDeplacement\fP"
.br
.RI "\fIÉtat représentant le déplacement d'un objet\&. \fP"
.ti -1c
.RI "class \fBEtatDuplication\fP"
.br
.RI "\fIÉtat représentant la duplication d'un objet\&. \fP"
.ti -1c
.RI "class \fBEtatLoupe\fP"
.br
.RI "\fIÉtat représentant le zoom sur une partie de l'écran\&. \fP"
.ti -1c
.RI "class \fBEtatMiseAEchelle\fP"
.br
.RI "\fIÉtat représentant la mise à échelle d'un objet\&. \fP"
.ti -1c
.RI "class \fBEtatRotation\fP"
.br
.RI "\fIÉtat représentant la rotation d'un objet\&. \fP"
.ti -1c
.RI "class \fBEtatSelection\fP"
.br
.RI "\fIÉtat représentant la sélection d'un objet\&. \fP"
.ti -1c
.RI "class \fBModeAbstrait\fP"
.br
.RI "\fIClasse qui représente le mode abstrait de notre machine à modes\&. \fP"
.ti -1c
.RI "class \fBModeConfigure\fP"
.br
.RI "\fIClasse qui représente le mode configure de notre machine à modes\&. \fP"
.ti -1c
.RI "class \fBModeEdition\fP"
.br
.RI "\fIClasse qui représente le mode edition de notre machine à modes\&. \fP"
.ti -1c
.RI "class \fBModeMenuPrincipal\fP"
.br
.RI "\fIClasse qui représente le mode menu principal de notre machine à modes\&. \fP"
.ti -1c
.RI "class \fBModeSimulation\fP"
.br
.RI "\fIClasse qui représente le mode simulation de notre machine à modes\&. \fP"
.ti -1c
.RI "class \fBModeTest\fP"
.br
.RI "\fIClasse qui représente le mode test de notre machine à modes\&. \fP"
.ti -1c
.RI "class \fBBancTests\fP"
.br
.RI "\fIBanc de tests qui permet d'exécuter tous les tests unitaires\&. C'est une classe singleton\&. \fP"
.ti -1c
.RI "class \fBConfigSceneTest\fP"
.br
.RI "\fIClasse de test cppunit pour tester le bon fonctionnement des méthodes de la classe \fBConfigScene\fP\&. \fP"
.ti -1c
.RI "class \fBNoeudAbstraitTest\fP"
.br
.RI "\fIClasse de test cppunit pour tester le bon fonctionnement des méthodes de la classe \fBNoeudAbstrait\fP\&. \fP"
.ti -1c
.RI "class \fBVisiteurAbstrait\fP"
.br
.RI "\fIClasse de base du patron visiteur utilisée pour effectuer des manipulations sur l'arbre de rendu\&. \fP"
.ti -1c
.RI "class \fBVisiteurCreationLigne\fP"
.br
.RI "\fIVisiteur permettant d'initialiser la création d'une ligne\&. \fP"
.ti -1c
.RI "class \fBVisiteurCreationMur\fP"
.br
.RI "\fIVisiteur permettant d'initialiser la création d'un mur\&. \fP"
.ti -1c
.RI "class \fBVisiteurCreationPoteau\fP"
.br
.RI "\fIVisiteur permettant d'initialiser la création d'un poteau\&. \fP"
.ti -1c
.RI "class \fBVisiteurDeplacement\fP"
.br
.RI "\fIVisiteur permettant d'effectuer le déplacement d'un objet\&. \fP"
.ti -1c
.RI "class \fBVisiteurDuplication\fP"
.br
.RI "\fIVisiteur permettant d'effectuer une duplication d'un objet\&. \fP"
.ti -1c
.RI "class \fBVisiteurMiseAEchelle\fP"
.br
.RI "\fIVisiteur permettant d'effectuer une mise à échelle d'un objet\&. \fP"
.ti -1c
.RI "class \fBVisiteurMiseAJourQuad\fP"
.br
.RI "\fIVisiteur permettant de mettre à jour la boite englobante d'un objet\&. \fP"
.ti -1c
.RI "class \fBVisiteurRotation\fP"
.br
.RI "\fIVisiteur permettant d'effectuer la rotation d'un objet\&. \fP"
.ti -1c
.RI "class \fBVisiteurSauvegarde\fP"
.br
.RI "\fICette classe s'occupe de visiter chaque noeuds de l'arbre de rendu pour écrire leurs attributs dans un fichier Json et ainsi, permettre de les charger plus tard\&. \fP"
.ti -1c
.RI "class \fBVisiteurSelection\fP"
.br
.RI "\fIVisiteur permettant d'effectuer la sélection d'un objet\&. \fP"
.ti -1c
.RI "class \fBVisiteurSuppression\fP"
.br
.RI "\fIVisiteur permettant d'effectuer la supression d'un objet\&. \fP"
.ti -1c
.RI "class \fBVisiteurVerificationQuad\fP"
.br
.ti -1c
.RI "class \fBInterfaceGraphique\&.PopOutInterface\fP"
.br
.ti -1c
.RI "class \fBInterfaceGraphique\&.Window\fP"
.br
.ti -1c
.RI "class \fBInterfaceGraphique\&.FonctionsNatives\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBEtat\fP { \fBSELECTION\fP, \fBDEPLACEMENT\fP, \fBROTATION\fP, \fBMISE_A_ECHELLE\fP, \fBDUPLICATION\fP, \fBCREATION_POTEAU\fP, \fBCREATION_MUR\fP, \fBCREATION_LIGNE_NOIRE\fP, \fBZOOM\fP }"
.br
.ti -1c
.RI "enum \fBMode\fP { \fBMENU_PRINCIPAL\fP, \fBSIMULATION\fP, \fBEDITION\fP, \fBCONFIGURE\fP, \fBTEST\fP }"
.br
.ti -1c
.RI "enum \fBEtat\fP { \fBSELECTION\fP, \fBDEPLACEMENT\fP, \fBROTATION\fP, \fBMISE_A_ECHELLE\fP, \fBDUPLICATION\fP, \fBCREATION_POTEAU\fP, \fBCREATION_MUR\fP, \fBCREATION_LIGNE_NOIRE\fP, \fBZOOM\fP }"
.br
.ti -1c
.RI "enum \fBMode\fP { \fBMENU_PRINCIPAL\fP, \fBSIMULATION\fP, \fBEDITION\fP, \fBCONFIGURE\fP, \fBTEST\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBSINGLETON_DECLARATION_CPP\fP (\fBConfigScene\fP)"
.br
.ti -1c
.RI "\fB__declspec\fP (dllexport) void __cdecl initialiserOpenGL(int *handle)"
.br
.ti -1c
.RI "\fBif\fP (autoriserInput)"
.br
.ti -1c
.RI "\fBif\fP (\fBFacadeModele::obtenirInstance\fP() \->obtenirAutorisationInputSouris())"
.br
.ti -1c
.RI "\fBSINGLETON_DECLARATION_CPP\fP (\fBBancTests\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST_SUITE_REGISTRATION\fP (\fBConfigSceneTest\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST_SUITE_REGISTRATION\fP (\fBNoeudAbstraitTest\fP)"
.br
.ti -1c
.RI "\fBInterfaceGraphique\&.PopOutInterface\&.PopOutInterface\fP ()"
.br
.ti -1c
.RI "void \fBInterfaceGraphique\&.Window\&.arreterToutMessage\fP ()"
.br
.ti -1c
.RI "bool \fBInterfaceGraphique\&.Window\&.PreFilterMessage\fP (ref Message m)"
.br
.ti -1c
.RI "\fBInterfaceGraphique\&.Window\&.Window\fP ()"
.br
.ti -1c
.RI "void \fBInterfaceGraphique\&.Window\&.InitialiserAnimation\fP ()"
.br
.ti -1c
.RI "void \fBInterfaceGraphique\&.Window\&.MettreAJour\fP (double tempsInterAffichage)"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.initialiserOpenGL\fP (IntPtr handle)"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.libererOpenGL\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.dessinerOpenGL\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.animer\fP (double temps)"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.assignerEtat\fP (Etat etat)"
.br
.ti -1c
.RI "static int \fBInterfaceGraphique\&.FonctionsNatives\&.obtenirEtat\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.assignerMode\fP (Mode mode)"
.br
.ti -1c
.RI "static int \fBInterfaceGraphique\&.FonctionsNatives\&.obtenirMode\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.redimensionnerFenetre\fP (int largeur, int hauteur)"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.zoomIn\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.zoomOut\fP ()"
.br
.ti -1c
.RI "static int \fBInterfaceGraphique\&.FonctionsNatives\&.obtenirAffichagesParSeconde\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.repartirMessage\fP (int msg, IntPtr wParam, IntPtr lParam)"
.br
.ti -1c
.RI "static double \fBInterfaceGraphique\&.FonctionsNatives\&.obtenirAngleRotation\fP ()"
.br
.ti -1c
.RI "static double \fBInterfaceGraphique\&.FonctionsNatives\&.obtenirFacteurGrandeur\fP ()"
.br
.ti -1c
.RI "static double \fBInterfaceGraphique\&.FonctionsNatives\&.obtenirPositionRelativeX\fP ()"
.br
.ti -1c
.RI "static double \fBInterfaceGraphique\&.FonctionsNatives\&.obtenirPositionRelativeY\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.assignerAngleRotation\fP (double angle)"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.assignerFacteurGrandeur\fP (double facteurMiseAEchelle)"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.assignerPositionRelativeX\fP (double positionRelativeX)"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.assignerPositionRelativeY\fP (double positionRelativeY)"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.sauvegarder\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.charger\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.suppression\fP ()"
.br
.ti -1c
.RI "static int \fBInterfaceGraphique\&.FonctionsNatives\&.obtenirNombreSelection\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.nouvelleTable\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.assignerCheminFichierZone\fP (string chemin)"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.assignerAutorisationInputClavier\fP (bool autorisation)"
.br
.ti -1c
.RI "static bool \fBInterfaceGraphique\&.FonctionsNatives\&.obtenirAutorisationInputClavier\fP ()"
.br
.ti -1c
.RI "static void \fBInterfaceGraphique\&.FonctionsNatives\&.assignerAutorisationInputSouris\fP (bool autorisation)"
.br
.ti -1c
.RI "static bool \fBInterfaceGraphique\&.FonctionsNatives\&.obtenirAutorisationInputSouris\fP ()"
.br
.ti -1c
.RI "static string \fBInterfaceGraphique\&.FonctionsNatives\&.obtenirCheminFichierZoneDefaut\fP ()"
.br
.ti -1c
.RI "static \fBFacadeModele\fP * \fBFacadeModele::obtenirInstance\fP ()"
.br
.RI "\fIObtient l'instance unique de la classe\&. \fP"
.ti -1c
.RI "static void \fBFacadeModele::libererInstance\fP ()"
.br
.RI "\fILibère l'instance unique de la classe\&. \fP"
.ti -1c
.RI "\fBFacadeModele::~FacadeModele\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "void \fBFacadeModele::initialiserOpenGL\fP (HWND hWnd)"
.br
.RI "\fICrée un contexte OpenGL et initialise celui-ci\&. \fP"
.ti -1c
.RI "void \fBFacadeModele::chargerConfiguration\fP () const "
.br
.RI "\fICharge la configuration à partir d'un fichier XML\&. \fP"
.ti -1c
.RI "void \fBFacadeModele::enregistrerConfiguration\fP () const "
.br
.RI "\fIEnregistre la configuration courante dans un fichier XML\&. \fP"
.ti -1c
.RI "void \fBFacadeModele::libererOpenGL\fP ()"
.br
.RI "\fILibère le contexte OpenGL\&. \fP"
.ti -1c
.RI "void \fBFacadeModele::afficher\fP () const "
.br
.RI "\fIAffiche le contenu du modèle\&. \fP"
.ti -1c
.RI "void \fBFacadeModele::afficherBase\fP () const "
.br
.RI "\fIAffiche la base du contenu du modèle\&. \fP"
.ti -1c
.RI "void \fBFacadeModele::reinitialiser\fP ()"
.br
.RI "\fIRéinitialise la scène\&. \fP"
.ti -1c
.RI "void \fBFacadeModele::animer\fP (float temps)"
.br
.RI "\fIAnime la scène\&. \fP"
.ti -1c
.RI "void \fBFacadeModele::assignerEtat\fP (Etat etat)"
.br
.RI "\fIModifie l'etat courant\&. \fP"
.ti -1c
.RI "void \fBFacadeModele::assignerMode\fP (Mode mode)"
.br
.RI "\fIModifie l'etat courant\&. \fP"
.ti -1c
.RI "int \fBFacadeModele::obtenirNombreSelection\fP ()"
.br
.ti -1c
.RI "double \fBFacadeModele::obtenirAngleRotation\fP ()"
.br
.ti -1c
.RI "double \fBFacadeModele::obtenirFacteurMiseAEchelle\fP ()"
.br
.ti -1c
.RI "double \fBFacadeModele::obtenirPositionRelativeX\fP ()"
.br
.ti -1c
.RI "double \fBFacadeModele::obtenirPositionRelativeY\fP ()"
.br
.ti -1c
.RI "void \fBFacadeModele::assignerAngleRotation\fP (const double &angle)"
.br
.ti -1c
.RI "void \fBFacadeModele::assignerFacteurMiseAEchelle\fP (const double &facteurMiseAEchelle)"
.br
.ti -1c
.RI "void \fBFacadeModele::assignerPositionRelativeX\fP (const double &positionRelativeX)"
.br
.ti -1c
.RI "void \fBFacadeModele::assignerPositionRelativeY\fP (const double &positionRelativeY)"
.br
.ti -1c
.RI "void \fBFacadeModele::continuerAffichage\fP ()"
.br
.ti -1c
.RI "void \fBFacadeModele::stopAffichage\fP ()"
.br
.ti -1c
.RI "\fBEtatAbstrait\fP * \fBFacadeModele::obtenirEtat\fP ()"
.br
.ti -1c
.RI "\fBModeAbstrait\fP * \fBFacadeModele::obtenirMode\fP ()"
.br
.ti -1c
.RI "vue::Vue * \fBFacadeModele::obtenirVue\fP ()"
.br
.RI "\fIRetourne la vue courante\&. \fP"
.ti -1c
.RI "\fBArbreRenduINF2990\fP * \fBFacadeModele::obtenirArbreRenduINF2990\fP () const "
.br
.RI "\fIRetourne l'arbre de rendu\&. \fP"
.ti -1c
.RI "\fBArbreRenduINF2990\fP * \fBFacadeModele::obtenirArbreRenduINF2990\fP ()"
.br
.RI "\fIRetourne l'arbre de rendu\&. \fP"
.ti -1c
.RI "bool \fBFacadeModele::obtenirAutorisationInputClavier\fP () const "
.br
.ti -1c
.RI "void \fBFacadeModele::assignerAutorisationInputClavier\fP (const bool &autorisation)"
.br
.ti -1c
.RI "bool \fBFacadeModele::obtenirAutorisationInputSouris\fP () const "
.br
.ti -1c
.RI "void \fBFacadeModele::assignerAutorisationInputSouris\fP (const bool &autorisation)"
.br
.ti -1c
.RI "\fBArbreRendu::ArbreRendu\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBArbreRendu::~ArbreRendu\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "std::shared_ptr< \fBNoeudAbstrait\fP > \fBArbreRendu::creerNoeud\fP (const std::string &typeNouveauNoeud) const "
.br
.RI "\fICrée un nouveau noeud\&. \fP"
.ti -1c
.RI "std::shared_ptr< \fBNoeudAbstrait\fP > \fBArbreRendu::ajouterNouveauNoeud\fP (const std::string &nomParent, const std::string &typeNouveauNoeud)"
.br
.RI "\fICrée et ajoute un nouveau noeud à l'arbre\&. \fP"
.ti -1c
.RI "static unsigned int \fBArbreRendu::calculerProfondeurMaximale\fP ()"
.br
.RI "\fICalcule la profondeur maximale possible pour l'arbre de rendu\&. \fP"
.ti -1c
.RI "void \fBArbreRendu::accepterVisiteur\fP (\fBVisiteurAbstrait\fP *visiteur)"
.br
.RI "\fIAccepter un visiteur\&. \fP"
.ti -1c
.RI "void \fBArbreRendu::assignerCheminFichierZone\fP (std::string chemin)"
.br
.RI "\fIAssigne le chemin du fichier sélectionné par l'utilisateur\&. \fP"
.ti -1c
.RI "FILE * \fBArbreRendu::obtenirFichierZone\fP (std::string mode)"
.br
.RI "\fIRetourne un pointeur vers le fichier sélectionné par l'utilisateur\&. \fP"
.ti -1c
.RI "FILE * \fBArbreRendu::obtenirFichierZoneDefaut\fP (std::string mode)"
.br
.RI "\fIRetourne un pointeur vers le fichier de structure de base\&. \fP"
.ti -1c
.RI "std::string \fBArbreRendu::obtenirCheminFichierZoneDefaut\fP ()"
.br
.RI "\fIRetourne le chemin vers le fichier de zone de base\&. \fP"
.ti -1c
.RI "void \fBArbreRendu::ajouterUsine\fP (const std::string &type, std::unique_ptr< const \fBUsineAbstraite\fP > usine)"
.br
.RI "\fIAjoute une usine associée à un type de noeud\&. \fP"
.ti -1c
.RI "\fBArbreRenduINF2990::ArbreRenduINF2990\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBArbreRenduINF2990::~ArbreRenduINF2990\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "void \fBArbreRenduINF2990::initialiser\fP ()"
.br
.RI "\fIInitialise l'arbre de rendu à son état initial\&. \fP"
.ti -1c
.RI "void \fBArbreRenduINF2990::chargerZone\fP ()"
.br
.RI "\fICharge le fichier de sauvegarde présentement assigné à l'arbre de rendu\&. \fP"
.ti -1c
.RI "\fBNoeudAbstrait::NoeudAbstrait\fP (const std::string &type=std::string{''})"
.br
.RI "\fIConstructeur\&. \fP"
.ti -1c
.RI "virtual \fBNoeudAbstrait::~NoeudAbstrait\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual unsigned int \fBNoeudAbstrait::calculerProfondeur\fP () const "
.br
.RI "\fICalcule la profondeur de l'arbre sous le noeud courant\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudAbstrait::vider\fP ()"
.br
.RI "\fIVide le noeud de ses enfants\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudAbstrait::effacer\fP (const \fBNoeudAbstrait\fP *noeud)"
.br
.RI "\fIEfface le noeud passé en paramètre\&. \fP"
.ti -1c
.RI "virtual const \fBNoeudAbstrait\fP * \fBNoeudAbstrait::chercher\fP (const std::string &typeNoeud) const "
.br
.RI "\fICherche un noeud par le type (sur un noeud constant)\&. \fP"
.ti -1c
.RI "virtual \fBNoeudAbstrait\fP * \fBNoeudAbstrait::chercher\fP (const std::string &typeNoeud)"
.br
.RI "\fICherche un noeud par le type\&. \fP"
.ti -1c
.RI "virtual const \fBNoeudAbstrait\fP * \fBNoeudAbstrait::chercher\fP (unsigned int indice) const "
.br
.RI "\fICherche un noeud enfant selon l'indice (sur un noeud constant)\&. \fP"
.ti -1c
.RI "virtual \fBNoeudAbstrait\fP * \fBNoeudAbstrait::chercher\fP (unsigned int indice)"
.br
.RI "\fICherche un noeud enfant selon l'indice\&. \fP"
.ti -1c
.RI "virtual bool \fBNoeudAbstrait::ajouter\fP (std::shared_ptr< \fBNoeudAbstrait\fP > enfant)"
.br
.RI "\fIAjoute un noeud enfant\&. \fP"
.ti -1c
.RI "virtual unsigned int \fBNoeudAbstrait::obtenirNombreEnfants\fP () const "
.br
.RI "\fIObtient le nombre d'enfants du noeud\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudAbstrait::inverserSelection\fP ()"
.br
.RI "\fIChanger la sélection du noeud\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudAbstrait::effacerSelection\fP ()"
.br
.RI "\fIEfface les enfants sélectionnés\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudAbstrait::selectionnerTout\fP ()"
.br
.RI "\fISélectionne tous les enfants de même que le noeud\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudAbstrait::deselectionnerTout\fP ()"
.br
.RI "\fIDésélectionne tous les enfants de même que le noeud\&. \fP"
.ti -1c
.RI "virtual bool \fBNoeudAbstrait::selectionExiste\fP () const "
.br
.RI "\fIVérifier si le noeud ou un de ses enfants est sélectionné\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudAbstrait::changerModePolygones\fP (bool estForce)"
.br
.RI "\fIChange le mode d'affichage des polygones\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudAbstrait::assignerModePolygones\fP (GLenum modePolygones)"
.br
.RI "\fIAssigne le mode d'affichage des polygones\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudAbstrait::afficher\fP () const "
.br
.RI "\fIAffiche le noeud\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudAbstrait::afficherConcret\fP () const "
.br
.RI "\fIAffiche le noeud de manière concrète\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudAbstrait::animer\fP (float dt)"
.br
.RI "\fIAnime le noeud\&. \fP"
.ti -1c
.RI "virtual modele::Modele3D const * \fBNoeudAbstrait::getModele\fP ()"
.br
.RI "\fIRetourne le modèle\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::toJson\fP (rapidjson::Writer< rapidjson::FileWriteStream > &writer)"
.br
.RI "\fIconvertit un noeud en JSON \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::fromJson\fP (rapidjson::Value::ConstValueIterator noeudJSON)"
.br
.RI "\fIassigne les attributs d'un noeud à partir d'un JSON \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::assignerObjetRendu\fP (modele::Modele3D const *modele, opengl::VBO const *liste)"
.br
.RI "\fIAssigne le modèle3D et la liste d'affichage du noeud courant\&. \fP"
.ti -1c
.RI "\fBNoeudAbstrait\fP * \fBNoeudAbstrait::obtenirParent\fP ()"
.br
.RI "\fIObtient le parent de ce noeud\&. \fP"
.ti -1c
.RI "const \fBNoeudAbstrait\fP * \fBNoeudAbstrait::obtenirParent\fP () const "
.br
.RI "\fIObtient le parent de ce noeud (version constante)\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::assignerParent\fP (\fBNoeudAbstrait\fP *parent)"
.br
.RI "\fIAssigne le parent de ce noeud\&. \fP"
.ti -1c
.RI "const glm::dvec3 & \fBNoeudAbstrait::obtenirPositionRelative\fP () const "
.br
.RI "\fIObtient la position relative du noeud\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::assignerPositionRelative\fP (const glm::dvec3 &positionRelative)"
.br
.RI "\fIAssigne la position relative du noeud\&. \fP"
.ti -1c
.RI "double \fBNoeudAbstrait::obtenirAngleRotation\fP () const "
.br
.RI "\fIObtient l'angle de rotation du noeud\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::assignerAngleRotation\fP (const double &angleRotation)"
.br
.RI "\fIAssigne l'angle de rotation du noeud par rapport au plan xy\&. \fP"
.ti -1c
.RI "double \fBNoeudAbstrait::obtenirFacteurMiseAEchelle\fP () const "
.br
.RI "\fIObtient le facteur de dimension du noeud\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::assignerFacteurMiseAEchelle\fP (const double &facteurDimension)"
.br
.RI "\fIAssigne le facteur de dimension\&. \fP"
.ti -1c
.RI "utilitaire::QuadEnglobant \fBNoeudAbstrait::obtenirQuadEnglobantCourant\fP () const "
.br
.RI "\fIObtient le quadrilatère englobant du noeud\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::assignerQuadEnglobantCourant\fP (const utilitaire::QuadEnglobant &quad)"
.br
.RI "\fIAssigne le quadrilatère englobant du noeud\&. \fP"
.ti -1c
.RI "utilitaire::QuadEnglobant \fBNoeudAbstrait::obtenirQuadEnglobantModele\fP () const "
.br
.RI "\fIObtenir la boite englobante du modèle\&. \fP"
.ti -1c
.RI "const std::string & \fBNoeudAbstrait::obtenirType\fP () const "
.br
.RI "\fIObtient le type du noeud\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::assignerAffiche\fP (bool affiche)"
.br
.RI "\fIÉcrit l'état de l'affichage du du noeud\&. \fP"
.ti -1c
.RI "bool \fBNoeudAbstrait::estAffiche\fP () const "
.br
.RI "\fIVérifie si le noeud se fait afficher\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::assignerSelection\fP (bool selectionne)"
.br
.RI "\fIÉcrit l'état de la sélection du noeud\&. \fP"
.ti -1c
.RI "bool \fBNoeudAbstrait::estSelectionne\fP () const "
.br
.RI "\fIVérifie si le noeud est sélectionné\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::assignerEstSelectionnable\fP (bool selectionnable)"
.br
.RI "\fIÉcrit si le noeud peut être sélectionné ou non\&. \fP"
.ti -1c
.RI "bool \fBNoeudAbstrait::estSelectionnable\fP () const "
.br
.RI "\fIVérifie si le noeud est sélectionnable\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstrait::assignerEstEnregistrable\fP (bool enregistrable)"
.br
.RI "\fIÉcrit si le noeud peut être enregistré ou non\&. \fP"
.ti -1c
.RI "bool \fBNoeudAbstrait::estEnregistrable\fP () const "
.br
.RI "\fIVérifie si le noeud est enregistrable\&. \fP"
.ti -1c
.RI "bool \fBNoeudAbstrait::assignerEstDuplicable\fP (bool estDuplicable)"
.br
.RI "\fIÉcrit si le noeud peut être enregistré ou non\&. \fP"
.ti -1c
.RI "bool \fBNoeudAbstrait::estDuplicable\fP () const "
.br
.RI "\fIVérifie si l'objet peut être dupliqué\&. \fP"
.ti -1c
.RI "\fBNoeudComposite::NoeudComposite\fP (const std::string &type=std::string{''})"
.br
.RI "\fIConstructeur\&. \fP"
.ti -1c
.RI "virtual \fBNoeudComposite::~NoeudComposite\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual unsigned int \fBNoeudComposite::calculerProfondeur\fP () const "
.br
.RI "\fICalcule la profondeur de l'arbre sous le noeud courant\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudComposite::vider\fP ()"
.br
.RI "\fIVide le noeud de ses enfants\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudComposite::effacer\fP (const \fBNoeudAbstrait\fP *noeud)"
.br
.RI "\fIEfface le noeud passé en paramètre\&. \fP"
.ti -1c
.RI "virtual const \fBNoeudAbstrait\fP * \fBNoeudComposite::chercher\fP (const std::string &typeNoeud) const "
.br
.RI "\fICherche un noeud par le type (sur un noeud constant)\&. \fP"
.ti -1c
.RI "virtual \fBNoeudAbstrait\fP * \fBNoeudComposite::chercher\fP (const std::string &typeNoeud)"
.br
.RI "\fICherche un noeud par le type\&. \fP"
.ti -1c
.RI "virtual const \fBNoeudAbstrait\fP * \fBNoeudComposite::chercher\fP (unsigned int indice) const "
.br
.RI "\fICherche un noeud enfant selon l'indice (sur un noeud constant)\&. \fP"
.ti -1c
.RI "virtual \fBNoeudAbstrait\fP * \fBNoeudComposite::chercher\fP (unsigned int indice)"
.br
.RI "\fICherche un noeud enfant selon l'indice\&. \fP"
.ti -1c
.RI "virtual bool \fBNoeudComposite::ajouter\fP (std::shared_ptr< \fBNoeudAbstrait\fP > enfant)"
.br
.RI "\fIAjoute un noeud enfant\&. \fP"
.ti -1c
.RI "virtual unsigned int \fBNoeudComposite::obtenirNombreEnfants\fP () const "
.br
.RI "\fIObtient le nombre d'enfants du noeud\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudComposite::effacerSelection\fP ()"
.br
.RI "\fIEfface les enfants sélectionnés\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudComposite::selectionnerTout\fP ()"
.br
.RI "\fISélectionne tous les enfants de même que le noeud\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudComposite::deselectionnerTout\fP ()"
.br
.RI "\fIDésélectionne tous les enfants de même que le noeud\&. \fP"
.ti -1c
.RI "virtual bool \fBNoeudComposite::selectionExiste\fP () const "
.br
.RI "\fIVérifier si le noeud ou un de ses enfants est sélectionné\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudComposite::changerModePolygones\fP (bool estForce)"
.br
.RI "\fIChange le mode d'affichage des polygones\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudComposite::assignerModePolygones\fP (GLenum modePolygones)"
.br
.RI "\fIAssigne le mode d'affichage des polygones\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudComposite::afficherConcret\fP () const "
.br
.RI "\fIAffiche le noeud de manière concrète\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudComposite::animer\fP (float dt)"
.br
.RI "\fIAnime le noeud\&. \fP"
.ti -1c
.RI "std::shared_ptr< const \fBNoeudAbstrait\fP > \fBNoeudComposite::getEnfant\fP (int indice) const "
.br
.ti -1c
.RI "std::vector< std::shared_ptr< \fBNoeudAbstrait\fP > > & \fBNoeudComposite::getEnfants\fP ()"
.br
.ti -1c
.RI "\fBNoeudDepart::NoeudDepart\fP (const std::string &typeNoeud)"
.br
.RI "\fIConstructeur à partir du type du noeud\&. \fP"
.ti -1c
.RI "\fBNoeudDepart::~NoeudDepart\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudDepart::afficherConcret\fP () const "
.br
.RI "\fIAffiche la table\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudDepart::accepterVisiteur\fP (\fBVisiteurAbstrait\fP *visiteur)"
.br
.ti -1c
.RI "\fBNoeudDuplication::NoeudDuplication\fP (const std::string &typeNoeud)"
.br
.RI "\fIConstructeur\&. \fP"
.ti -1c
.RI "\fBNoeudDuplication::~NoeudDuplication\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudDuplication::afficherConcret\fP () const "
.br
.RI "\fIAffiche la table\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudDuplication::accepterVisiteur\fP (\fBVisiteurAbstrait\fP *visiteur)"
.br
.ti -1c
.RI "std::shared_ptr< \fBNoeudAbstrait\fP > \fBNoeudDuplication::obtenirDuplication\fP (const int &indice)"
.br
.RI "\fIObtenir le pointeur intelligent d'un noeud dans le but de faire un transfert de possession\&. \fP"
.ti -1c
.RI "\fBNoeudPoteau::NoeudPoteau\fP (const std::string &typeNoeud)"
.br
.RI "\fIConstructeur\&. \fP"
.ti -1c
.RI "\fBNoeudJonction::NoeudJonction\fP (const std::string &typeNoeud)"
.br
.RI "\fIConstructeur\&. \fP"
.ti -1c
.RI "\fBNoeudPoteau::~NoeudPoteau\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "\fBNoeudJonction::~NoeudJonction\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudPoteau::afficherConcret\fP () const "
.br
.RI "\fIAffiche la table\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudJonction::afficherConcret\fP () const "
.br
.RI "\fIAffiche la table\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudJonction::accepterVisiteur\fP (\fBVisiteurAbstrait\fP *visiteur)"
.br
.ti -1c
.RI "\fBNoeudLigne::NoeudLigne\fP (const std::string &typeNoeud)"
.br
.RI "\fIConstructeur\&. \fP"
.ti -1c
.RI "\fBNoeudLigne::~NoeudLigne\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudLigne::afficherConcret\fP () const "
.br
.RI "\fIAffiche la table\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudLigne::accepterVisiteur\fP (\fBVisiteurAbstrait\fP *visiteur)"
.br
.ti -1c
.RI "\fBNoeudMur::NoeudMur\fP (const std::string &typeNoeud)"
.br
.RI "\fIConstructeur\&. \fP"
.ti -1c
.RI "\fBNoeudMur::~NoeudMur\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudMur::afficherConcret\fP () const "
.br
.RI "\fIAffiche la table\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudMur::accepterVisiteur\fP (\fBVisiteurAbstrait\fP *visiteur)"
.br
.ti -1c
.RI "virtual void \fBNoeudPoteau::accepterVisiteur\fP (\fBVisiteurAbstrait\fP *visiteur)"
.br
.ti -1c
.RI "\fBNoeudRobot::NoeudRobot\fP (const std::string &typeNoeud)"
.br
.RI "\fIConstructeur à partir du type du noeud\&. \fP"
.ti -1c
.RI "\fBNoeudRobot::~NoeudRobot\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudRobot::afficherConcret\fP () const "
.br
.RI "\fIAffiche le robot\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudRobot::accepterVisiteur\fP (\fBVisiteurAbstrait\fP *visiteur)"
.br
.ti -1c
.RI "\fBNoeudSegment::NoeudSegment\fP (const std::string &typeNoeud)"
.br
.RI "\fIConstructeur\&. \fP"
.ti -1c
.RI "\fBNoeudSegment::~NoeudSegment\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudSegment::accepterVisiteur\fP (\fBVisiteurAbstrait\fP *visiteur)"
.br
.ti -1c
.RI "virtual void \fBNoeudSegment::afficherConcret\fP () const "
.br
.RI "\fIAffiche le segment\&. \fP"
.ti -1c
.RI "\fBNoeudTable::NoeudTable\fP (const std::string &typeNoeud)"
.br
.RI "\fIConstructeur\&. \fP"
.ti -1c
.RI "\fBNoeudTable::~NoeudTable\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudTable::afficherConcret\fP () const "
.br
.RI "\fIAffiche la table\&. \fP"
.ti -1c
.RI "virtual void \fBNoeudTable::accepterVisiteur\fP (\fBVisiteurAbstrait\fP *visiteur)"
.br
.RI "\fIAccepter un visiteur\&. \fP"
.ti -1c
.RI "const std::string & \fBUsineAbstraite::obtenirNom\fP () const "
.br
.RI "\fIRetourne le nom associé à l'usine\&. \fP"
.ti -1c
.RI "virtual std::shared_ptr< \fBNoeudAbstrait\fP > \fBUsineNoeud< Noeud >::creerNoeud\fP () const  override"
.br
.RI "\fIFonction à surcharger pour la création d'un noeud\&. \fP"
.ti -1c
.RI "void \fBConfigScene::creerDOM\fP (tinyxml2::XMLDocument &document) const "
.br
.RI "\fICréer le DOM avec les valeurs\&. \fP"
.ti -1c
.RI "void \fBConfigScene::lireDOM\fP (tinyxml2::XMLDocument const &document)"
.br
.RI "\fILire les valeurs du DOM\&. \fP"
.ti -1c
.RI "\fBEtatAbstrait::EtatAbstrait\fP ()"
.br
.ti -1c
.RI "virtual \fBEtatAbstrait::~EtatAbstrait\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererClicDroitEnfonce\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererClicDroitRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererClicGaucheEnfonce\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "bool \fBEtatAbstrait::estClickDrag\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererToucheEchappe\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererToucheControlEnfoncee\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererToucheControlRelachee\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererToucheAltEnfoncee\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererToucheAltRelachee\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererTouchePlus\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererToucheMoins\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererMoletteSouris\fP (const int &delta)"
.br
.ti -1c
.RI "void \fBEtatAbstrait::gererPositionCurseur\fP (const glm::dvec3 &position)"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::gererPositionCurseurConcret\fP (const bool &pointeurEstSurTable)"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::assignerSymboleCurseur\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatAbstrait::reinitialiser\fP ()"
.br
.ti -1c
.RI "Etat \fBEtatAbstrait::obtenirTypeEtat\fP () const "
.br
.ti -1c
.RI "\fBEtatCreationLigne::EtatCreationLigne\fP ()"
.br
.ti -1c
.RI "virtual \fBEtatCreationLigne::~EtatCreationLigne\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatCreationLigne::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatCreationLigne::gererToucheEchappe\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatCreationLigne::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatCreationLigne::gererToucheControlEnfoncee\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatCreationLigne::gererToucheControlRelachee\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatCreationMur::gererPositionCurseurConcret\fP (const bool &positionEstSurTable)"
.br
.ti -1c
.RI "virtual void \fBEtatCreationLigne::gererPositionCurseurConcret\fP (const bool &positionEstSurTable)"
.br
.ti -1c
.RI "virtual void \fBEtatCreationLigne::assignerSymboleCurseur\fP ()"
.br
.ti -1c
.RI "\fBEtatCreationMur::EtatCreationMur\fP ()"
.br
.ti -1c
.RI "virtual \fBEtatCreationMur::~EtatCreationMur\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatCreationMur::gererClicGaucheEnfonce\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatCreationMur::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatCreationMur::gererToucheEchappe\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatCreationMur::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatCreationMur::assignerSymboleCurseur\fP ()"
.br
.ti -1c
.RI "\fBEtatCreationPoteau::EtatCreationPoteau\fP ()"
.br
.ti -1c
.RI "virtual \fBEtatCreationPoteau::~EtatCreationPoteau\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatCreationPoteau::gererClicGaucheEnfonce\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatCreationPoteau::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatCreationPoteau::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatCreationPoteau::gererPositionCurseurConcret\fP (const bool &positionEstSurTable)"
.br
.ti -1c
.RI "virtual void \fBEtatCreationPoteau::assignerSymboleCurseur\fP ()"
.br
.ti -1c
.RI "\fBEtatDeplacement::EtatDeplacement\fP ()"
.br
.ti -1c
.RI "virtual \fBEtatDeplacement::~EtatDeplacement\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatDeplacement::gererClicGaucheEnfonce\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatDeplacement::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatDeplacement::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatDeplacement::reinitialiser\fP ()"
.br
.ti -1c
.RI "\fBEtatDuplication::EtatDuplication\fP ()"
.br
.ti -1c
.RI "virtual \fBEtatDuplication::~EtatDuplication\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatDuplication::gererPositionCurseurConcret\fP (const bool &positionEstSurTable)"
.br
.ti -1c
.RI "virtual void \fBEtatDuplication::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatDuplication::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatDuplication::assignerSymboleCurseur\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatLoupe::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatLoupe::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "\fBEtatMiseAEchelle::EtatMiseAEchelle\fP ()"
.br
.ti -1c
.RI "virtual \fBEtatMiseAEchelle::~EtatMiseAEchelle\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatMiseAEchelle::gererClicGaucheEnfonce\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatMiseAEchelle::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatMiseAEchelle::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatMiseAEchelle::reinitialiser\fP ()"
.br
.ti -1c
.RI "\fBEtatRotation::EtatRotation\fP ()"
.br
.ti -1c
.RI "virtual \fBEtatRotation::~EtatRotation\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatRotation::gererClicGaucheEnfonce\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatRotation::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatRotation::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatRotation::reinitialiser\fP ()"
.br
.ti -1c
.RI "\fBEtatSelection::EtatSelection\fP ()"
.br
.ti -1c
.RI "virtual \fBEtatSelection::~EtatSelection\fP ()"
.br
.ti -1c
.RI "virtual void \fBEtatSelection::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBEtatSelection::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "void \fBEtatSelection::gererClicGauche\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "void \fBEtatSelection::gererDragGauche\fP (const int &xAvant, const int &yAvant, const int &xApres, const int &yApres)"
.br
.ti -1c
.RI "void \fBEtatSelection::gererToucheControlEnfoncee\fP ()"
.br
.ti -1c
.RI "void \fBEtatSelection::gererToucheControlRelachee\fP ()"
.br
.ti -1c
.RI "\fBModeAbstrait::ModeAbstrait\fP ()"
.br
.ti -1c
.RI "virtual \fBModeAbstrait::~ModeAbstrait\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererTouchePlus\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheMoins\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheEchappe\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheB\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheC\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheD\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheE\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheJ\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheK\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheL\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheR\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheS\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheT\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheZ\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheCTRLavecS\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheCTRLavecN\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheCTRLavecO\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererTouche1\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererTouche2\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererTouche3\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererFlecheGauche\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererFlecheBas\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererFlecheHaut\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererFlecheDroit\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererBarreDespacement\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheArriere\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheControlEnfoncee\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheControlRelachee\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::sauvegarder\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::charger\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererToucheSupprimer\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererClicDroitEnfonce\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererClicDroitRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererClicGaucheEnfonce\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBModeAbstrait::gererMoletteSouris\fP (const int &delta)"
.br
.ti -1c
.RI "int \fBModeAbstrait::obtenirTypeMode\fP ()"
.br
.ti -1c
.RI "\fBModeConfigure::ModeConfigure\fP ()"
.br
.ti -1c
.RI "virtual \fBModeConfigure::~ModeConfigure\fP ()"
.br
.ti -1c
.RI "\fBModeEdition::ModeEdition\fP ()"
.br
.ti -1c
.RI "virtual \fBModeEdition::~ModeEdition\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererTouchePlus\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheMoins\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheEchappe\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheC\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheD\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheE\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheR\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheS\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheT\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheZ\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheCTRLavecS\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheCTRLavecN\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheCTRLavecO\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererTouche1\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererTouche2\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererFlecheGauche\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererFlecheBas\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererFlecheHaut\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererFlecheDroit\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheControlEnfoncee\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheControlRelachee\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::sauvegarder\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::charger\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheSupprimer\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheAltEnfoncee\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererToucheAltRelachee\fP ()"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererClicDroitEnfonce\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererClicDroitRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererClicGaucheEnfonce\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererClicGaucheRelache\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererMouvementSouris\fP (const int &x, const int &y)"
.br
.ti -1c
.RI "virtual void \fBModeEdition::gererMoletteSouris\fP (const int &delta)"
.br
.ti -1c
.RI "\fBModeMenuPrincipal::ModeMenuPrincipal\fP ()"
.br
.ti -1c
.RI "virtual \fBModeMenuPrincipal::~ModeMenuPrincipal\fP ()"
.br
.ti -1c
.RI "\fBModeSimulation::ModeSimulation\fP ()"
.br
.ti -1c
.RI "virtual \fBModeSimulation::~ModeSimulation\fP ()"
.br
.ti -1c
.RI "\fBModeTest::ModeTest\fP ()"
.br
.ti -1c
.RI "virtual \fBModeTest::~ModeTest\fP ()"
.br
.ti -1c
.RI "bool \fBBancTests::executer\fP ()"
.br
.RI "\fIExécuter tous les tests unitaires\&. \fP"
.ti -1c
.RI "void \fBConfigSceneTest::setUp\fP ()"
.br
.RI "\fITraitement à effectuer pour initialiser cette suite de tests\&. \fP"
.ti -1c
.RI "void \fBConfigSceneTest::tearDown\fP ()"
.br
.RI "\fITraitement à effectuer pour 'finaliser' cette suite de tests\&. \fP"
.ti -1c
.RI "void \fBConfigSceneTest::testSauvegardeChargement\fP ()"
.br
.RI "\fICas de test: sauvegarde et chargement XML de la configuration\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstraitTest::setUp\fP ()"
.br
.RI "\fITraitement à effectuer pour initialiser cette suite de tests\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstraitTest::tearDown\fP ()"
.br
.RI "\fITraitement à effectuer pour 'finaliser' cette suite de tests\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstraitTest::testPositionRelative\fP ()"
.br
.RI "\fICas de test: écriture/lecture de la position relative\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstraitTest::testType\fP ()"
.br
.RI "\fICas de test: type de noeud\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstraitTest::testSelection\fP ()"
.br
.RI "\fICas de test: définition/obtention des états de sélection du noeud\&. \fP"
.ti -1c
.RI "void \fBNoeudAbstraitTest::testEnfants\fP ()"
.br
.RI "\fICas de test: s'assurer que le noeud abstrait n'a pas d'enfant\&. \fP"
.ti -1c
.RI "void \fBVisiteurAbstrait::assignerPositionRelative\fP (glm::dvec3 positionRelative)"
.br
.ti -1c
.RI "void \fBVisiteurAbstrait::assignerPositionRelativeAvant\fP (glm::dvec3 positionRelativeAvant)"
.br
.ti -1c
.RI "void \fBVisiteurAbstrait::assignerPositionRelativeApres\fP (glm::dvec3 positionRelativeApres)"
.br
.ti -1c
.RI "void \fBVisiteurAbstrait::assignerAngleRotation\fP (double angleRotation)"
.br
.ti -1c
.RI "void \fBVisiteurAbstrait::assignerFacteurMiseAEchelle\fP (double facteurDimension)"
.br
.ti -1c
.RI "\fBNoeudAbstrait\fP * \fBVisiteurAbstrait::obtenirReferenceNoeud\fP ()"
.br
.ti -1c
.RI "void \fBVisiteurAbstrait::assignerEstAffiche\fP (const bool &estAffiche)"
.br
.ti -1c
.RI "void \fBVisiteurAbstrait::assignerEstDrag\fP (const bool &estDrag)"
.br
.ti -1c
.RI "bool \fBVisiteurAbstrait::obtenirEstDrag\fP ()"
.br
.ti -1c
.RI "\fBVisiteurCreationLigne::VisiteurCreationLigne\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurCreationLigne::~VisiteurCreationLigne\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurCreationLigne::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.RI "\fICreation de poteau sur l'arbre de rendu\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurCreationLigne::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.RI "\fICreation de poteau sur la table\&. \fP"
.ti -1c
.RI "\fBVisiteurCreationMur::VisiteurCreationMur\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurCreationMur::~VisiteurCreationMur\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurCreationMur::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.RI "\fICreation de poteau sur l'arbre de rendu\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurCreationMur::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.RI "\fICreation de poteau sur la table\&. \fP"
.ti -1c
.RI "\fBVisiteurCreationPoteau::VisiteurCreationPoteau\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurCreationPoteau::~VisiteurCreationPoteau\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurCreationPoteau::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.RI "\fICreation de poteau sur l'arbre de rendu\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurCreationPoteau::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.RI "\fICreation de poteau sur la table\&. \fP"
.ti -1c
.RI "\fBVisiteurDeplacement::VisiteurDeplacement\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurDeplacement::~VisiteurDeplacement\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurDeplacement::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurDeplacement::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.ti -1c
.RI "\fBVisiteurDuplication::VisiteurDuplication\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurDuplication::~VisiteurDuplication\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurDuplication::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurDuplication::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurDuplication::visiter\fP (\fBNoeudPoteau\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurDuplication::visiter\fP (\fBNoeudMur\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurDuplication::visiter\fP (\fBNoeudLigne\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurDuplication::visiter\fP (\fBNoeudDuplication\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurDuplication::visiter\fP (\fBNoeudSegment\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurDuplication::visiter\fP (\fBNoeudJonction\fP *noeud)"
.br
.ti -1c
.RI "void \fBVisiteurDuplication::assignerEnDuplication\fP (bool enDuplication)"
.br
.ti -1c
.RI "\fBNoeudAbstrait\fP * \fBVisiteurDuplication::obtenirDuplication\fP ()"
.br
.ti -1c
.RI "\fBVisiteurMiseAEchelle::VisiteurMiseAEchelle\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurMiseAEchelle::~VisiteurMiseAEchelle\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "void \fBVisiteurMiseAEchelle::initialiser\fP (\fBArbreRendu\fP *arbre)"
.br
.ti -1c
.RI "void \fBVisiteurMiseAEchelle::reinitialiser\fP (\fBArbreRendu\fP *arbre)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAEchelle::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAEchelle::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAEchelle::visiter\fP (\fBNoeudPoteau\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAEchelle::visiter\fP (\fBNoeudMur\fP *noeud)"
.br
.ti -1c
.RI "\fBVisiteurMiseAJourQuad::VisiteurMiseAJourQuad\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurMiseAJourQuad::~VisiteurMiseAJourQuad\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurMiseAJourQuad::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAJourQuad::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAJourQuad::visiter\fP (\fBNoeudDuplication\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAJourQuad::visiter\fP (\fBNoeudPoteau\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAJourQuad::visiter\fP (\fBNoeudMur\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAJourQuad::visiter\fP (\fBNoeudLigne\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAJourQuad::visiter\fP (\fBNoeudSegment\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAJourQuad::visiter\fP (\fBNoeudJonction\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurMiseAJourQuad::visiter\fP (\fBNoeudDepart\fP *noeud)"
.br
.ti -1c
.RI "\fBVisiteurRotation::VisiteurRotation\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurRotation::~VisiteurRotation\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurRotation::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurRotation::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurRotation::visiter\fP (\fBNoeudPoteau\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurRotation::visiter\fP (\fBNoeudMur\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurRotation::visiter\fP (\fBNoeudDepart\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurRotation::visiter\fP (\fBNoeudLigne\fP *noeud)"
.br
.ti -1c
.RI "\fBVisiteurSauvegarde::VisiteurSauvegarde\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurSauvegarde::~VisiteurSauvegarde\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurSauvegarde::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.RI "\fISauvegarde en JSON de l'arbre de rendu\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurSauvegarde::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.RI "\fISauvegarde en JSON d'un \fBNoeudTable\fP\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurSauvegarde::visiter\fP (\fBNoeudPoteau\fP *noeud)"
.br
.RI "\fISauvegarde en JSON d'un \fBNoeudPoteau\fP\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurSauvegarde::visiter\fP (\fBNoeudMur\fP *noeud)"
.br
.RI "\fISauvegarde en JSON d'un \fBNoeudMur\fP\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurSauvegarde::visiter\fP (\fBNoeudLigne\fP *noeud)"
.br
.RI "\fISauvegarde en JSON d'un \fBNoeudLigne\fP\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurSauvegarde::visiter\fP (\fBNoeudSegment\fP *noeud)"
.br
.RI "\fISauvegarde en JSON d'un \fBNoeudSegment\fP\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurSauvegarde::visiter\fP (\fBNoeudDepart\fP *noeud)"
.br
.RI "\fISauvegarde en JSON d'un \fBNoeudDuplication\fP\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurSauvegarde::visiter\fP (\fBNoeudJonction\fP *noeud)"
.br
.RI "\fISauvegarde en JSON d'un \fBNoeudDuplication\fP\&. \fP"
.ti -1c
.RI "\fBVisiteurSelection::VisiteurSelection\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurSelection::~VisiteurSelection\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurSelection::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.RI "\fIParcours du noeudTable\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurSelection::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.ti -1c
.RI "void \fBVisiteurSelection::assignerControl\fP (bool ctrlAppuye)"
.br
.ti -1c
.RI "void \fBVisiteurSelection::assignerPositionRectElast\fP (const glm::dvec3 &positionPremierClic, const glm::dvec3 &positionDeuxiemeClic)"
.br
.ti -1c
.RI "virtual void \fBVisiteurSelection::visiter\fP (\fBNoeudPoteau\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurSelection::visiter\fP (\fBNoeudMur\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurSelection::visiter\fP (\fBNoeudLigne\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurSelection::visiter\fP (\fBNoeudDepart\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurSelection::visiter\fP (\fBNoeudSegment\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurSelection::visiter\fP (\fBNoeudJonction\fP *noeud)"
.br
.ti -1c
.RI "bool \fBVisiteurSelection::quadEstDansRectangleElastique\fP (const utilitaire::QuadEnglobant &quad)"
.br
.ti -1c
.RI "\fBVisiteurSuppression::VisiteurSuppression\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurSuppression::~VisiteurSuppression\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurSuppression::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.RI "\fIParcours du noeudTable\&. \fP"
.ti -1c
.RI "\fBVisiteurVerificationQuad::VisiteurVerificationQuad\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurVerificationQuad::~VisiteurVerificationQuad\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurVerificationQuad::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurVerificationQuad::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurVerificationQuad::visiter\fP (\fBNoeudDuplication\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurVerificationQuad::visiter\fP (\fBNoeudPoteau\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurVerificationQuad::visiter\fP (\fBNoeudMur\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurVerificationQuad::visiter\fP (\fBNoeudDepart\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurVerificationQuad::visiter\fP (\fBNoeudLigne\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurVerificationQuad::visiter\fP (\fBNoeudSegment\fP *noeud)"
.br
.ti -1c
.RI "bool \fBVisiteurVerificationQuad::objetsDansZoneSimulation\fP ()"
.br
.RI "\fIObtenir si tous les objets sont dans la zone de simulation\&. \fP"
.ti -1c
.RI "\fBVisiteurAbstrait::VisiteurAbstrait\fP ()"
.br
.RI "\fIConstructeur par défaut\&. \fP"
.ti -1c
.RI "virtual \fBVisiteurAbstrait::~VisiteurAbstrait\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "virtual void \fBVisiteurAbstrait::visiter\fP (\fBArbreRendu\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurAbstrait::visiter\fP (\fBNoeudTable\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurAbstrait::visiter\fP (\fBNoeudPoteau\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurAbstrait::visiter\fP (\fBNoeudMur\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurAbstrait::visiter\fP (\fBNoeudLigne\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurAbstrait::visiter\fP (\fBNoeudDuplication\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurAbstrait::visiter\fP (\fBNoeudSegment\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurAbstrait::visiter\fP (\fBNoeudDepart\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurAbstrait::visiter\fP (\fBNoeudJonction\fP *noeud)"
.br
.ti -1c
.RI "virtual void \fBVisiteurAbstrait::visiter\fP (\fBNoeudRobot\fP *noeud)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const int \fBVK_KEY_D\fP = 0x44"
.br
.ti -1c
.RI "const int \fBVK_KEY_S\fP = 0x53"
.br
.ti -1c
.RI "const int \fBVK_KEY_R\fP = 0x52"
.br
.ti -1c
.RI "const int \fBVK_KEY_E\fP = 0x45"
.br
.ti -1c
.RI "const int \fBVK_KEY_C\fP = 0x43"
.br
.ti -1c
.RI "const int \fBVK_KEY_Z\fP = 0x5A"
.br
.ti -1c
.RI "const int \fBVK_KEY_T\fP = 0x54"
.br
.ti -1c
.RI "int \fBhauteur\fP"
.br
.ti -1c
.RI "int \fBlongueur\fP"
.br
.ti -1c
.RI "WPARAM \fBwParam\fP"
.br
.ti -1c
.RI "WPARAM LPARAM \fBlParam\fP"
.br
.ti -1c
.RI "bool \fBautoriserInput\fP = \fBFacadeModele::obtenirInstance\fP()\->obtenirAutorisationInputClavier()"
.br
.ti -1c
.RI "int \fBhauteur\fP"
.br
.ti -1c
.RI "int \fBlongueur\fP"
.br
.ti -1c
.RI "WPARAM \fBwParam\fP"
.br
.ti -1c
.RI "WPARAM LPARAM \fBlParam\fP"
.br
.ti -1c
.RI "static const std::string \fBArbreRenduINF2990::NOM_ROBOT\fP { 'robot' }"
.br
.RI "\fILa chaîne représentant le type du robot\&. \fP"
.ti -1c
.RI "static const std::string \fBArbreRenduINF2990::NOM_TABLE\fP { 'table' }"
.br
.RI "\fILa chaîne représentant le type de la table\&. \fP"
.ti -1c
.RI "static const std::string \fBArbreRenduINF2990::NOM_POTEAU\fP { 'poteau' }"
.br
.RI "\fILa chaîne représentant le type des poteaux\&. \fP"
.ti -1c
.RI "static const std::string \fBArbreRenduINF2990::NOM_MUR\fP { 'mur' }"
.br
.RI "\fILa chaîne représentant le type des murs\&. \fP"
.ti -1c
.RI "static const std::string \fBArbreRenduINF2990::NOM_LIGNENOIRE\fP { 'ligneNoire' }"
.br
.RI "\fILa chaîne représentant le type des lignes\&. \fP"
.ti -1c
.RI "static const std::string \fBArbreRenduINF2990::NOM_SEGMENT\fP { 'segment' }"
.br
.RI "\fILa chaîne représentant le type des segments\&. \fP"
.ti -1c
.RI "static const std::string \fBArbreRenduINF2990::NOM_DUPLICATION\fP { 'duplication' }"
.br
.RI "\fILa chaîne représentant le type des duplications\&. \fP"
.ti -1c
.RI "static const std::string \fBArbreRenduINF2990::NOM_JONCTION\fP { 'jonction' }"
.br
.RI "\fILa chaîne représentant le type du point de départ\&. \fP"
.ti -1c
.RI "static int \fBConfigScene::CALCULS_PAR_IMAGE\fP { 50 }"
.br
.RI "\fINombre de calculs par image\&. \fP"
.ti -1c
.RI "static glm::ivec2 \fBEtatAbstrait::currentPosition_\fP = { 0\&.0, 0\&.0 }"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Function Documentation"
.PP 
.SS "__declspec (dllexport)"
\fB__declspec(dllexport)\fP void __cdecl initialiserOpenGL(int* handle)
.PP
Cette fonction initialise un contexte OpenGL dans la fenêtre identifiée par le handle passé en paramètre\&. Cette fonction doit être la première à être appelée, car la création de l'objet du modèle C++ s'attend à avoir un contexte OpenGL valide\&.
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP : Le handle\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
\fB__declspec(dllexport)\fP void __cdecl redimensionnerFenetre(int largeur, int hauteur)
.PP
Cette fonction doit être appelée lorsque la fenêtre est redimensionnée afin d'ajuster les paramètres de la machine à états d'OpenGL pour correspondre aux nouvelles dimensions de la fenêtre\&.
.PP
\fBParameters:\fP
.RS 4
\fIlargeur\fP : La nouvelle largeur de la fenêtre\&. 
.br
\fIhauteur\fP : La nouvelle hauteur de la fenêtre\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Cette fonction libère le contexte OpenGL\&. Cette fonction doit être la dernière à être appelée, car elle libère également l'objet du modèle C++\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Cette fonction affiche la scène\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Cette fonction effectue les différents calculs d'animations nécessaires pour le mode jeu, tel que les différents calculs de physique du jeu\&.
.PP
\fBParameters:\fP
.RS 4
\fItemps\fP : Intervalle de temps sur lequel effectuer le calcul\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Cette fonction écrit la structure de l'arbre de rendu dans un fichier qui a été charger au préalable\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Cette fonction charge un fichier sélectionné par l'utilisateur\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Cette fonction assigne le chemin vers le fichier sélectionné par l'utilisateur\&.
.PP
\fBParameters:\fP
.RS 4
\fIchemin\fP : chemin vers le fichier de zone
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Cette fonction permet d'obtenir le chemin vers le fichier de zone par défaut\&.
.PP
\fBParameters:\fP
.RS 4
\fIchemin\fP : contenur pour la string représentant le chemin versle fichier de zone par défaut 
.br
\fIlongueur\fP : taille du conteneur
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Cette fonction applique un zoom avant sur le présent volume de vision\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Cette fonction applique un zoom arrière sur le présent volume de vision\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Cette fonction permet d'obtenir le nombre d'affichages par seconde\&.
.PP
\fBReturns:\fP
.RS 4
Le nombre d'affichage par seconde\&.
.RE
.PP
Cette fonction permet d'exécuter l'ensemble des tests unitaires
.PP
\fBReturns:\fP
.RS 4
0 si tous les tests ont réussi, 1 si au moins un test a échoué
.RE
.PP
Cette fonction permet d'assigner un Etat
.PP
\fBParameters:\fP
.RS 4
\fIint\fP etat : Le numero de l'état selectionné
.RE
.PP
Cette fonction permet d'obtenir un Etat
.PP
\fBReturns:\fP
.RS 4
int etat : Le numero du mode sélectionné
.RE
.PP
Cette fonction permet d'assigner un Mode
.PP
\fBParameters:\fP
.RS 4
\fIint\fP mode : Le numero du mode sélectionné
.RE
.PP
Cette fonction permet d'obtenir un Mode
.PP
\fBReturns:\fP
.RS 4
int mode : Le numero du mode sélectionné
.RE
.PP
Cette fonction permet d'obtenir l'angle de rotation d'un objet
.PP
\fBReturns:\fP
.RS 4
doublee : l'angle de rotation de l'objet
.RE
.PP
Cette fonction permet d'obtenir le facteur de grandissement d'un objet
.PP
\fBReturns:\fP
.RS 4
doublee : le facteur de grandissement d'un objet
.RE
.PP
Cette fonction permet d'obtenir la position relative en X
.PP
\fBReturns:\fP
.RS 4
doublee : la position relative en X
.RE
.PP
Cette fonction permet d'obtenir la position relative en Y
.PP
\fBReturns:\fP
.RS 4
doublee : la position relative en Y
.RE
.PP
Cette fonction permet de supprimer tous les objets de la table
.PP
Cette fonction permet de supprimer un objet selectionné
.PP
Cette fonction retourne le nombre d'objet selectionné
.PP
\fBParameters:\fP
.RS 4
\fIint\fP : le nombre d'objet selectionné
.RE
.PP
Cette fonction retourne l'autorisation des inputs claviers
.PP
\fBReturns:\fP
.RS 4
bool : l'autorisation des inputs claviers
.RE
.PP
Cette fonction assigne l'autorisation des inputs claviers
.PP
\fBParameters:\fP
.RS 4
\fIbool\fP : l'autorisation des inputs claviers
.RE
.PP
Cette fonction retourne l'autorisation des inputs souris
.PP
\fBReturns:\fP
.RS 4
bool : l'autorisation des inputs souris
.RE
.PP
Cette fonction assigne l'autorisation des inputs souris
.PP
\fBParameters:\fP
.RS 4
\fIbool\fP : l'autorisation des inputs souris
.RE
.PP
Cette fonction permet d'assigner l'angle de rotation
.PP
\fBParameters:\fP
.RS 4
\fIdouble\fP : l'angle de rotation\&.
.RE
.PP
Cette fonction permet d'assigner le facteur de mise à échelle\&.
.PP
\fBParameters:\fP
.RS 4
\fIdouble\fP : l'angle de rotation\&.
.RE
.PP
Cette fonction permmet d'assigner une position relative en X\&.
.PP
\fBParameters:\fP
.RS 4
\fIpositionRelativeX\fP : la position relative en X\&.
.RE
.PP
Cette fonction permet d'assigner une position relative en Y\&.
.PP
\fBParameters:\fP
.RS 4
\fIpositionRelativeX\fP : la position relative en Y\&.
.RE
.PP
Cette fonction permet de repartir le traitement de certains messages provenant de l'interface utilisateur, principalement les messages concerant les entrées avec la souris et le clavier\&. Voir https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx/ pour la documentation sur la signification des codes virtuels\&.
.PP
\fBParameters:\fP
.RS 4
\fIUINT\fP msg : L'identificateur du message\&.
.br
\fIWPARAM\fP wParam : Information additionnelle du message\&.
.br
\fILPARAM\fP lParam : Information additionnelle du message\&. 
.RE
.PP

.SS "void NoeudDepart::accepterVisiteur (\fBVisiteurAbstrait\fP * visiteur)\fC [virtual]\fP"
Cette fonction prend le pointeur de ce noeud et le passe au visiteur pour que ce dernier puisse déléguer sa tâche à la méthode qui se charge de ce type de noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIvisiteur\fP le pointeur au visiteur abstrait\&. (pour déléguer au concret après)
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Implements \fBNoeudAbstrait\fP\&.
.SS "void NoeudJonction::accepterVisiteur (\fBVisiteurAbstrait\fP * visiteur)\fC [virtual]\fP"
Cette fonction prend le pointeur de ce noeud et le passe au visiteur pour que ce dernier puisse déléguer sa tâche à la méthode qui se charge de ce type de noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIvisiteur\fP le pointeur au visiteur abstrait\&. (pour déléguer au concret après)
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Implements \fBNoeudAbstrait\fP\&.
.SS "void NoeudLigne::accepterVisiteur (\fBVisiteurAbstrait\fP * visiteur)\fC [virtual]\fP"
Cette fonction prend le pointeur de ce noeud et le passe au visiteur pour que ce dernier puisse déléguer sa tâche à la méthode qui se charge de ce type de noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIvisiteur\fP le pointeur au visiteur abstrait\&. (pour déléguer au concret après)
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Implements \fBNoeudAbstrait\fP\&.
.SS "void NoeudRobot::accepterVisiteur (\fBVisiteurAbstrait\fP * visiteur)\fC [virtual]\fP"
Cette fonction prend le pointeur de ce noeud et le passe au visiteur pour que ce dernier puisse déléguer sa tâche à la méthode qui se charge de ce type de noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIvisiteur\fP le pointeur au visiteur abstrait\&. (pour déléguer au concret après)
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Implements \fBNoeudAbstrait\fP\&.
.SS "void NoeudMur::accepterVisiteur (\fBVisiteurAbstrait\fP * visiteur)\fC [virtual]\fP"
Cette fonction prend le pointeur de ce noeud et le passe au visiteur pour que ce dernier puisse déléguer sa tâche à la méthode qui se charge de ce type de noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIvisiteur\fP le pointeur au visiteur abstrait\&. (pour déléguer au concret après)
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Implements \fBNoeudAbstrait\fP\&.
.SS "void NoeudPoteau::accepterVisiteur (\fBVisiteurAbstrait\fP * visiteur)\fC [virtual]\fP"
Cette fonction prend le pointeur de ce noeud et le passe au visiteur pour que ce dernier puisse déléguer sa tâche à la méthode qui se charge de ce type de noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIvisiteur\fP le pointeur au visiteur abstrait\&. (pour déléguer au concret après)
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Implements \fBNoeudAbstrait\fP\&.
.SS "void NoeudSegment::accepterVisiteur (\fBVisiteurAbstrait\fP * visiteur)\fC [virtual]\fP"
Cette fonction prend le pointeur de ce noeud et le passe au visiteur pour que ce dernier puisse déléguer sa tâche à la méthode qui se charge de ce type de noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIvisiteur\fP le pointeur au visiteur abstrait\&. (pour déléguer au concret après)
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Implements \fBNoeudAbstrait\fP\&.
.SS "void NoeudTable::accepterVisiteur (\fBVisiteurAbstrait\fP * visiteur)\fC [virtual]\fP"

.PP
Accepter un visiteur\&. Cette fonction prend le pointeur de ce noeud et le passe au visiteur pour que ce dernier puisse déléguer sa tâche à la méthode qui se charge de ce type de noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIvisiteur\fP le pointeur au visiteur abstrait\&. (pour déléguer au concret après)
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Implements \fBNoeudAbstrait\fP\&.
.SS "void NoeudDuplication::accepterVisiteur (\fBVisiteurAbstrait\fP * visiteur)\fC [virtual]\fP"
Cette fonction prend le pointeur de ce noeud et le passe au visiteur pour que ce dernier puisse déléguer sa tâche à la méthode qui se charge de ce type de noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIvisiteur\fP le pointeur au visiteur abstrait\&. (pour déléguer au concret après)
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Implements \fBNoeudAbstrait\fP\&.
.SS "void ArbreRendu::accepterVisiteur (\fBVisiteurAbstrait\fP * visiteur)\fC [virtual]\fP"

.PP
Accepter un visiteur\&. Fonction faisant partie du patron visiteur\&. Celle-ci permet à un noeud d'accepter un visiteur en appelant la fonction visiter de celui-ci\&.
.PP
\fBParameters:\fP
.RS 4
\fIvisiteur\fP : Pointeur vers le visiteur qui doit être accepté par le noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Implements \fBNoeudAbstrait\fP\&.
.SS "void FacadeModele::afficher () const"

.PP
Affiche le contenu du modèle\&. Cette fonction affiche le contenu de la scène\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstrait::afficher () const\fC [virtual]\fP"

.PP
Affiche le noeud\&. Cette fonction affiche le noeud comme tel\&.
.PP
Elle consiste en une template method (dans le sens du patron de conception, et non les template C++) qui effectue ce qui est généralement à faire pour l'affichage, c'est-à-dire:
.IP "\(bu" 2
Mise en pile de la matrice de transformation
.IP "\(bu" 2
Translation du noeud pour qu'il soit à sa position relative
.IP "\(bu" 2
Utilisation du mode d'affichage des polygones
.IP "\(bu" 2
\&.\&.\&.
.IP "\(bu" 2
Restauration de l'état\&.
.PP
.PP
L'affichage comme tel est confié à la fonction \fBafficherConcret()\fP, appelée par la fonction \fBafficher()\fP\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void FacadeModele::afficherBase () const"

.PP
Affiche la base du contenu du modèle\&. Cette fonction affiche la base du contenu de la scène, c'est-à-dire qu'elle met en place l'éclairage et affiche les objets\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudDepart::afficherConcret () const\fC [virtual]\fP"

.PP
Affiche la table\&. Cette fonction effectue le véritable rendu de l'objet\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Cette fonction appelle l'affichage des éléments à dupliquer
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void NoeudLigne::afficherConcret () const\fC [virtual]\fP"

.PP
Affiche la table\&. Cette fonction effectue le véritable rendu de l'objet\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudComposite\fP\&.
.SS "void NoeudRobot::afficherConcret () const\fC [virtual]\fP"

.PP
Affiche le robot\&. Cette fonction effectue le véritable rendu de l'objet\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudComposite\fP\&.
.SS "void NoeudPoteau::afficherConcret () const\fC [virtual]\fP"

.PP
Affiche la table\&. Cette fonction effectue le véritable rendu de l'objet\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void NoeudMur::afficherConcret () const\fC [virtual]\fP"

.PP
Affiche la table\&. Cette fonction effectue le véritable rendu de l'objet\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void NoeudSegment::afficherConcret () const\fC [virtual]\fP"

.PP
Affiche le segment\&. Cette fonction effectue le véritable rendu de l'objet\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void NoeudTable::afficherConcret () const\fC [virtual]\fP"

.PP
Affiche la table\&. Cette fonction effectue le véritable rendu de l'objet\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudComposite\fP\&.
.SS "void NoeudComposite::afficherConcret () const\fC [virtual]\fP"

.PP
Affiche le noeud de manière concrète\&. Cette fonction effectue le véritable rendu de l'objet\&. Elle est appelée par la template method (dans le sens du patron de conception, et non des template C++) \fBafficher()\fP de la classe de base\&.
.PP
Pour cette classe, elle affiche chacun des enfants du noeud\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.PP
Reimplemented in \fBNoeudTable\fP, \fBNoeudDuplication\fP, \fBNoeudLigne\fP, and \fBNoeudRobot\fP\&.
.SS "void NoeudAbstrait::afficherConcret () const\fC [virtual]\fP"

.PP
Affiche le noeud de manière concrète\&. Cette fonction effectue le véritable rendu de l'objet\&. Elle est appelée par la template method (dans le sens du patron de conception, et non des template C++) \fBafficher()\fP de la classe de base\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP, \fBNoeudTable\fP, \fBNoeudDuplication\fP, \fBNoeudSegment\fP, \fBNoeudMur\fP, \fBNoeudPoteau\fP, \fBNoeudDepart\fP, \fBNoeudJonction\fP, \fBNoeudLigne\fP, and \fBNoeudRobot\fP\&.
.SS "bool NoeudComposite::ajouter (std::shared_ptr< \fBNoeudAbstrait\fP > enfant)\fC [virtual]\fP"

.PP
Ajoute un noeud enfant\&. Ajoute un noeud enfant au noeud courant\&.
.PP
\fBParameters:\fP
.RS 4
\fIenfant\fP Noeud à ajouter\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Vrai si l'ajout a réussi, donc en tout temps pour cette classe\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "bool NoeudAbstrait::ajouter (std::shared_ptr< \fBNoeudAbstrait\fP > enfant)\fC [virtual]\fP"

.PP
Ajoute un noeud enfant\&. Cette fonction ajoute un enfant à ce noeud\&.
.PP
Elle retourne toujours faux et ne fait rien, car ce type de noeud abstrait ne peut pas avoir d'enfant\&.
.PP
\fBParameters:\fP
.RS 4
\fIenfant\fP Le noeud à ajouter\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Vrai si l'ajout a bien été effectué, faux autrement\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "std::shared_ptr< \fBNoeudAbstrait\fP > ArbreRendu::ajouterNouveauNoeud (const std::string & typeParent, const std::string & typeNouveauNoeud)"

.PP
Crée et ajoute un nouveau noeud à l'arbre\&. Cette fonction permet d'ajouter un nouveau noeud dans l'arbre de rendu\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeParent\fP : Le type du parent du nouveau noeud\&. 
.br
\fItypeNouveauNoeud\fP : Le type du nouveau noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Le noeud nouvellement créé\&. 
.RE
.PP

.SS "void ArbreRendu::ajouterUsine (const std::string & type, std::unique_ptr< const \fBUsineAbstraite\fP > usine)\fC [inline]\fP"

.PP
Ajoute une usine associée à un type de noeud\&. Cette fonction permet d'ajouter une usine qui sera ensuite utilisée pour créer de nouveaux noeuds\&.
.PP
\fBParameters:\fP
.RS 4
\fItype\fP : La chaîne qui identifie le type de noeuds à créer avec cette usine\&. 
.br
\fIusine\fP : L'usine ajoutée\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudComposite::animer (float dt)\fC [virtual]\fP"

.PP
Anime le noeud\&. Anime tous les enfants de ce noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIdt\fP : Intervalle de temps sur lequel faire l'animation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void FacadeModele::animer (float temps)"

.PP
Anime la scène\&. Cette fonction effectue les différents calculs d'animations nécessaires pour le mode jeu, tel que les différents calculs de physique du jeu\&.
.PP
\fBParameters:\fP
.RS 4
\fItemps\fP : Intervalle de temps sur lequel effectuer le calcul\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstrait::animer (float dt)\fC [virtual]\fP"

.PP
Anime le noeud\&. Cette fonction effectue l'animation du noeud pour un certain intervalle de temps\&.
.PP
Elle ne fait rien pour cette classe et vise à être surcharger par les classes dérivées\&.
.PP
\fBParameters:\fP
.RS 4
\fIdt\fP : Intervalle de temps sur lequel faire l'animation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "ArbreRendu::ArbreRendu ()"

.PP
Constructeur par défaut\&. Ne fait qu'assigner que ce noeud n'est pas sélectionnable\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "ArbreRenduINF2990::ArbreRenduINF2990 ()"

.PP
Constructeur par défaut\&. Ce constructeur crée toutes les usines qui seront utilisées par le projet de INF2990et les enregistre auprès de la classe de base\&. Il crée également la structure de base de l'arbre de rendu, c'est-à-dire avec les noeuds structurants\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "void NoeudAbstrait::assignerAffiche (bool affiche)\fC [inline]\fP"

.PP
Écrit l'état de l'affichage du du noeud\&. Cette fonction permet d'assigner si le noeud se fait afficher ou non lorsque l'arbre de rendu se fait afficher\&. Elle permet donc de temporairement suspendre ou activer l'affichage d'un noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIaffiche\fP : L'état affiché ou non\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.SS "void VisiteurAbstrait::assignerAngleRotation (double angleRotation)\fC [inline]\fP"
Fonction qui assigne l'angle de rotation
.PP
\fBParameters:\fP
.RS 4
\fIangleRotation\fP : angle de rotation
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstrait::assignerAngleRotation (const double & angleRotation)\fC [inline]\fP"

.PP
Assigne l'angle de rotation du noeud par rapport au plan xy\&. Cette fonction permet d'assigner un angle de rotation en sens horaire au noeud par rapport à son centre\&.
.PP
\fBParameters:\fP
.RS 4
\fIangleRotation\fP : Le nouvel angle de rotation de l'objet\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.SS "void FacadeModele::assignerAngleRotation (const double & angle)"
Cette fonction assigne un angle de rotation à un noeud seulement s'il est encore sur la table
.PP
\fBParameters:\fP
.RS 4
\fIdouble\fP angle: l'angle a assigner a l'objet 
.RE
.PP

.SS "void ArbreRendu::assignerCheminFichierZone (std::string chemin)"

.PP
Assigne le chemin du fichier sélectionné par l'utilisateur\&. Fonction servant à assigner le chemin d'un fichier de zone sélectionné par un utilisateur à la variable cheminFichierZone\&.
.PP
\fBParameters:\fP
.RS 4
\fIchemin\fP : Chemin vers le fichier\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.SS "void VisiteurDuplication::assignerEnDuplication (bool enDuplication)\fC [inline]\fP"
Assigne l'attribut enDuplication qui indique si une duplication est en cours
.PP
\fBParameters:\fP
.RS 4
\fIenDuplication\fP : valeur que l'on veut affigner à l'attribut\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void VisiteurAbstrait::assignerEstAffiche (const bool & estAffiche)\fC [inline]\fP"
Fonction qui assigne le booléen estAffiche selon si \&.\&.\&. est affiché ou non\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP bool& estAffiche : booléen qui indique si \&.\&.\&. est affiché ou non\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void VisiteurAbstrait::assignerEstDrag (const bool & estDrag)\fC [inline]\fP"
Fonction qui assigne le booléen estDrag selon s'il s'agit d'un drag ou d'un simple clic\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP bool& estDrag : booléen qui indique s'il s'agit d'un drag ou d'un simple clic\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "bool NoeudAbstrait::assignerEstDuplicable (bool estDuplicable)\fC [inline]\fP"

.PP
Écrit si le noeud peut être enregistré ou non\&. Cette méthode permet d'assigner l'état d'être duplicable ou non du noeud\&.
.PP
\fBReturns:\fP
.RS 4
L'état enregistrable ou non\&. 
.RE
.PP

.SS "void NoeudAbstrait::assignerEstEnregistrable (bool enregistrable)\fC [inline]\fP"

.PP
Écrit si le noeud peut être enregistré ou non\&. Cette fonction permet d'assigner l'état d'être entregistrable ou non du noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIenregistrable\fP : L'état enregistrable ou non\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.SS "void NoeudAbstrait::assignerEstSelectionnable (bool selectionnable)\fC [inline]\fP"

.PP
Écrit si le noeud peut être sélectionné ou non\&. Cette fonction permet d'assigner l'état d'être sélectionnable ou non du noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIselectionnable\fP : L'état sélectionnable ou non\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.SS "void VisiteurAbstrait::assignerFacteurMiseAEchelle (double facteurDimension)\fC [inline]\fP"
Fonction qui assigne le facteur de mise à échelle
.PP
\fBParameters:\fP
.RS 4
\fIfacteurDimension\fP : facteur de mise à échelle\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstrait::assignerFacteurMiseAEchelle (const double & facteurDimension)\fC [inline]\fP"

.PP
Assigne le facteur de dimension\&. Cette fonction permet d'assigner une nouvelle échelle d'agrandissement au Noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIfacteurDimension\fP : Le facteur de redimentionnement de l'objet\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.SS "void FacadeModele::assignerMode (Mode mode)"

.PP
Modifie l'etat courant\&. Cette fonction change l'attribut mode_ pour la valeur du mode en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fIetat\fP : Nouveau mode à traiter\&. 
.RE
.PP

.SS "void NoeudComposite::assignerModePolygones (GLenum modePolygones)\fC [virtual]\fP"

.PP
Assigne le mode d'affichage des polygones\&. Cette fonction assigne le mode de rendu des polygones du noeud et de ses enfants\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void NoeudAbstrait::assignerModePolygones (GLenum modePolygones)\fC [virtual]\fP"

.PP
Assigne le mode d'affichage des polygones\&. Cette fonction assigne le mode de rendu des polygones du noeud\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "void NoeudAbstrait::assignerObjetRendu (modele::Modele3D const * modele, opengl::VBO const * liste)\fC [inline]\fP"

.PP
Assigne le modèle3D et la liste d'affichage du noeud courant\&. Cette fonction assigne l'objet de rendu au modèle, c'est-à-dire son modèle 3D et sa liste d'affichage
.PP
\fBParameters:\fP
.RS 4
\fImodele\fP : le modèle 3D 
.br
\fIliste\fP : la liste d'affichage OpenGL 
.RE
.PP

.SS "void NoeudAbstrait::assignerParent (\fBNoeudAbstrait\fP * parent)\fC [inline]\fP"

.PP
Assigne le parent de ce noeud\&. Cette fonction assigne le parent du noeud afin qu'il soit possible de remonter dans l'arbre\&.
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP : Le parent du noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.SS "void VisiteurSelection::assignerPositionRectElast (const glm::dvec3 & positionPremierClic, const glm::dvec3 & positionDeuxiemeClic)"
Fonction qui assigne les attributs correspondants aux coins du rectangle élastique\&.
.PP
\fBParameters:\fP
.RS 4
\fIpositionPremierClic\fP : position virtuelle du premier clic du rectangle positionDeuxiemeClic: position virtuelle du deuxième clic du rectangle
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void VisiteurAbstrait::assignerPositionRelative (glm::dvec3 positionRelative)\fC [inline]\fP"
Fonction qui assigne la positionRelative d'un clic
.PP
\fBParameters:\fP
.RS 4
\fIpositionRelative\fP : position du clic
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstrait::assignerPositionRelative (const glm::dvec3 & positionRelative)\fC [inline]\fP"

.PP
Assigne la position relative du noeud\&. Cette fonction permet d'assigner la position relative du noeud par rapport à son parent\&.
.PP
\fBParameters:\fP
.RS 4
\fIpositionRelative\fP : La position relative\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune
.RE
.PP
Cette fonction permet d'obtenir l'angle de rotation affectant présentement ce noeud\&.
.PP
\fBReturns:\fP
.RS 4
l'angle de rotation en degrees du noeud 
.RE
.PP

.SS "void VisiteurAbstrait::assignerPositionRelativeApres (glm::dvec3 positionRelativeApres)\fC [inline]\fP"
Fonction qui assigne la positionRelative où le clic est relaché\&.
.PP
\fBParameters:\fP
.RS 4
\fIpositionRelativeApres\fP : position où le clic est relaché\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void VisiteurAbstrait::assignerPositionRelativeAvant (glm::dvec3 positionRelativeAvant)\fC [inline]\fP"
Fonction qui assigne la positionRelative d'un clic (lors d'un drag)
.PP
\fBParameters:\fP
.RS 4
\fIpositionRelativeAvant\fP : position du clic
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void FacadeModele::assignerPositionRelativeX (const double & positionRelativeX)"
Cette fonction assigne une position en X à un noeud seulement s'il est encore sur la table
.PP
\fBParameters:\fP
.RS 4
\fIdouble\fP angle: position en X de l'objet 
.RE
.PP

.SS "void FacadeModele::assignerPositionRelativeY (const double & positionRelativeY)"
Cette fonction assigne une position en Y à un noeud seulement s'il est encore sur la table
.PP
\fBParameters:\fP
.RS 4
\fIdouble\fP angle: position en Y de l'objet 
.RE
.PP

.SS "void NoeudAbstrait::assignerQuadEnglobantCourant (const utilitaire::QuadEnglobant & quadEnglobant)\fC [inline]\fP"

.PP
Assigne le quadrilatère englobant du noeud\&. Cette fonction permet d'assigner le nouveau quad englobant au noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIquadEnglobant\fP : Le nouveau plan des bornes pour la sélection
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstrait::assignerSelection (bool selectionne)\fC [inline]\fP"

.PP
Écrit l'état de la sélection du noeud\&. Cette fonction permet d'assigner l'état d'être sélectionné ou non du noeud\&.
.PP
\fBParameters:\fP
.RS 4
\fIselectionne\fP : L'état sélectionné ou non\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.SS "void EtatDuplication::assignerSymboleCurseur ()\fC [virtual]\fP"
Cette fonction assigne le symbole interdit au curseur si celui-ci ne se trouve pas sur la table\&. 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationPoteau::assignerSymboleCurseur ()\fC [virtual]\fP"
Cette fonction assigne le symbole interdit au curseur si celui-ci ne se trouve pas sur la table\&. 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationMur::assignerSymboleCurseur ()\fC [virtual]\fP"
Cette fonction assigne le symbole interdit au curseur si celui-ci ne se trouve pas sur la table\&. 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationLigne::assignerSymboleCurseur ()\fC [virtual]\fP"
Cette fonction assigne le symbole interdit au curseur si celui-ci ne se trouve pas sur la table\&. 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatAbstrait::assignerSymboleCurseur ()\fC [virtual]\fP"
Cette fonction assigne le symbole interdit au curseur si celui-ci ne se trouve pas sur la table\&. 
.PP
Reimplemented in \fBEtatCreationLigne\fP, \fBEtatCreationMur\fP, \fBEtatCreationPoteau\fP, and \fBEtatDuplication\fP\&.
.SS "unsigned int NoeudComposite::calculerProfondeur () const\fC [virtual]\fP"

.PP
Calcule la profondeur de l'arbre sous le noeud courant\&. Cette fonction calcule la profondeur de l'arbre incluant le noeud courant ainsi que tous ses enfants\&.
.PP
Cette fonction retourne toujours 1 de plus que la profondeur de son enfants le plus profond\&.
.PP
\fBReturns:\fP
.RS 4
La profondeur de l'arbre sous ce noeud\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "unsigned int NoeudAbstrait::calculerProfondeur () const\fC [virtual]\fP"

.PP
Calcule la profondeur de l'arbre sous le noeud courant\&. Cette fonction calcule la profondeur de l'arbre incluant le noeud courant ainsi que tous ses enfants\&.
.PP
Cette fonction retourne toujours 1 pour un noeud sans enfant\&.
.PP
\fBReturns:\fP
.RS 4
La profondeur de l'arbre sous ce noeud, donc toujours 1\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "unsigned int ArbreRendu::calculerProfondeurMaximale ()\fC [static]\fP"

.PP
Calcule la profondeur maximale possible pour l'arbre de rendu\&. Cette fonction retourne la profondeur maximale possible de l'arbre\&. Comme lors du rendu, on effectue un glPushMatrix() pour sauvegarder les transformations, ainsi qu'un glPushName() pour ajouter un nom sur la pile des noms pour la sélection, la profondeur maximale de l'arbre est limitée par la taille de la pile des matrices ainsi que par celle de la pile des noms pour la sélection\&.
.PP
Cette fonction vérifie donc ces deux valeurs et retourne la plus petite, c'est-à-dire celle qui limite la profondeur de l'arbre\&.
.PP
\fBReturns:\fP
.RS 4
La profondeur maximale possible de l'arbre de rendu\&. 
.RE
.PP

.SS "void NoeudComposite::changerModePolygones (bool estForce)\fC [virtual]\fP"

.PP
Change le mode d'affichage des polygones\&. Change le mode d'affichage des polygones pour ce noeud et ses enfants\&.
.PP
\fBParameters:\fP
.RS 4
\fIestForce\fP : Si vrai, le mode est changé pour ce noeud et tous ses descendants\&. Sinon, seuls les noeuds sélectionnés verront leur mode changer\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void NoeudAbstrait::changerModePolygones (bool estForce)\fC [virtual]\fP"

.PP
Change le mode d'affichage des polygones\&. Cette fonction change le mode de rendu des polygones du noeud s'il est sélectionné ou si on le force\&.
.PP
\fBParameters:\fP
.RS 4
\fIestForce\fP Vrai si on veut changer le mode même si le noeud n'est pas sélectionné\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "void ModeAbstrait::charger ()\fC [virtual]\fP"
Cette fonction permet de gérer le chargement selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::charger ()\fC [virtual]\fP"
Cette fonction permet de gérer le chargement selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void FacadeModele::chargerConfiguration () const"

.PP
Charge la configuration à partir d'un fichier XML\&. Cette fonction charge la configuration à partir d'un fichier XML si ce dernier existe\&. Sinon, le fichier de configuration est généré à partir de valeurs par défaut directement dans le code\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void ArbreRenduINF2990::chargerZone ()"

.PP
Charge le fichier de sauvegarde présentement assigné à l'arbre de rendu\&. Cette fonction s'occupe de récupérer le fichier json contenant une configuration quelconque de l'arbre de rendu sauvegardé par un utilisateur\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "const \fBNoeudAbstrait\fP * NoeudComposite::chercher (const std::string & typeNoeud) const\fC [virtual]\fP"

.PP
Cherche un noeud par le type (sur un noeud constant)\&. Recherche un noeud d'un type donné parmi le noeud courant et ses enfants\&. Version constante de la fonction\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud cherché\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Noeud recherché ou 0 si le noeud n'est pas trouvé\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "\fBNoeudAbstrait\fP * NoeudComposite::chercher (const std::string & typeNoeud)\fC [virtual]\fP"

.PP
Cherche un noeud par le type\&. Recherche un noeud d'un type donné parmi le noeud courant et ses enfants\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud cherché\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Noeud recherché ou 0 si le noeud n'est pas trouvé\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "const \fBNoeudAbstrait\fP * NoeudComposite::chercher (unsigned int indice) const\fC [virtual]\fP"

.PP
Cherche un noeud enfant selon l'indice (sur un noeud constant)\&. Retourne le i-ème enfant, où i est l'indice passé à la fonction\&. Version constante de la fonction\&.
.PP
\fBParameters:\fP
.RS 4
\fIindice\fP : L'indice de l'enfant cherché\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Noeud recherché ou 0 si le noeud n'est pas trouvé\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "\fBNoeudAbstrait\fP * NoeudComposite::chercher (unsigned int indice)\fC [virtual]\fP"

.PP
Cherche un noeud enfant selon l'indice\&. Retourne le i-ème enfant, où i est l'indice passé à la fonction\&.
.PP
\fBParameters:\fP
.RS 4
\fIindice\fP : L'indice de l'enfant cherché\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Noeud recherché ou 0 si le noeud n'est pas trouvé\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "const \fBNoeudAbstrait\fP * NoeudAbstrait::chercher (const std::string & typeNoeud) const\fC [virtual]\fP"

.PP
Cherche un noeud par le type (sur un noeud constant)\&. Cette fonction cherche un noeud d'un type donné parmi le noeud lui-même et ses enfants\&.
.PP
Elle retourne donc le noeud lui-même si son type est celui passé en paramètre, ou 0 sinon\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud à trouver\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Le pointeur vers le noeud s'il est trouvé\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "\fBNoeudAbstrait\fP * NoeudAbstrait::chercher (const std::string & typeNoeud)\fC [virtual]\fP"

.PP
Cherche un noeud par le type\&. Cette fonction cherche un noeud d'un type donné parmi le noeud lui-même et ses enfants\&.
.PP
Elle retourne donc le noeud lui-même si son type est celui passé en paramètre, ou 0 sinon\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud à trouver\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Le pointeur vers le noeud s'il est trouvé\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "const \fBNoeudAbstrait\fP * NoeudAbstrait::chercher (unsigned int indice) const\fC [virtual]\fP"

.PP
Cherche un noeud enfant selon l'indice (sur un noeud constant)\&. Cette fonction cherche le i-ème enfant d'un noeud\&.
.PP
Elle retourne toujours 0 pour la classe de base, car cette dernière ne possède pas d'enfant\&.
.PP
\fBParameters:\fP
.RS 4
\fIindice\fP : L'indice du noeud à trouver\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Le pointeur vers le noeud s'il est trouvé\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "\fBNoeudAbstrait\fP * NoeudAbstrait::chercher (unsigned int indice)\fC [virtual]\fP"

.PP
Cherche un noeud enfant selon l'indice\&. Cette fonction cherche le i-ème enfant d'un noeud\&.
.PP
Elle retourne toujours 0 pour la classe de base, car cette dernière ne possède pas d'enfant\&.
.PP
\fBParameters:\fP
.RS 4
\fIindice\fP : L'indice du noeud à trouver\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Le pointeur vers le noeud s'il est trouvé\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "void FacadeModele::continuerAffichage ()"
Cette fonction assigne la valeur d'un booléan à vrai si l'on veut continuer a afficher l'animation 
.SS "void ConfigScene::creerDOM (tinyxml2::XMLDocument & document) const"

.PP
Créer le DOM avec les valeurs\&. Cette fonction écrit les valeurs de la configuration dans un élément XML\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "std::shared_ptr< \fBNoeudAbstrait\fP > ArbreRendu::creerNoeud (const std::string & typeNouveauNoeud) const"

.PP
Crée un nouveau noeud\&. Cette fonction permet de créer un nouveau noeud, sans l'ajouter directement à l'arbre de rendu\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNouveauNoeud\fP : Le type du nouveau noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Le noeud nouvellement créé\&. 
.RE
.PP

.SS "template<typename Noeud > std::shared_ptr< \fBNoeudAbstrait\fP > \fBUsineNoeud\fP< Noeud >::creerNoeud () const\fC [override]\fP, \fC [virtual]\fP"

.PP
Fonction à surcharger pour la création d'un noeud\&. Cette fonction retourne un noeud nouvellement créé du type produit par cette usine\&.
.PP
\fBReturns:\fP
.RS 4
Le noeud nouvellement créé\&. 
.RE
.PP

.PP
Implements \fBUsineAbstraite\fP\&.
.SS "void NoeudComposite::deselectionnerTout ()\fC [virtual]\fP"

.PP
Désélectionne tous les enfants de même que le noeud\&. Désélectionne tous les noeuds qui sont sélectionnés parmis les les descendants de ce noeud, lui-même étant inclus\&.
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void NoeudAbstrait::deselectionnerTout ()\fC [virtual]\fP"

.PP
Désélectionne tous les enfants de même que le noeud\&. Cette fonction désélectionne le noeud et ses enfants\&.
.PP
Elle ne fait que désélectionner le noeud pour cette classe, car ce type de noeud abstrait ne peut pas avoir d'enfants\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "void NoeudComposite::effacer (const \fBNoeudAbstrait\fP * noeud)\fC [virtual]\fP"

.PP
Efface le noeud passé en paramètre\&. Efface un noeud qui est un enfant ou qui est contenu dans un des enfants\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud à effacer\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void NoeudAbstrait::effacer (const \fBNoeudAbstrait\fP * noeud)\fC [virtual]\fP"

.PP
Efface le noeud passé en paramètre\&. Cette fonction efface le noeud s'il fait partie des enfants de ce noeud\&.
.PP
Cette fonction ne fait rien pour un noeud sans enfant, elle ne fait donc rien dans cette implantation par défaut de la classe de base\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud à effacer\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "void NoeudComposite::effacerSelection ()\fC [virtual]\fP"

.PP
Efface les enfants sélectionnés\&. Efface tous les noeuds sélectionnés situés sous ce noeud\&. Elle s'appelle donc récursivement sur tous les enfants, avant de retirer les enfants sélectionnés\&.
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void NoeudAbstrait::effacerSelection ()\fC [virtual]\fP"

.PP
Efface les enfants sélectionnés\&. Cette fonction efface les noeuds qui sont sélectionnés parmi les enfants de ce noeud\&.
.PP
Elle ne fait rien, car ce type de noeud abstrait ne peut pas avoir d'enfant\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "void FacadeModele::enregistrerConfiguration () const"

.PP
Enregistre la configuration courante dans un fichier XML\&. Cette fonction génère un fichier XML de configuration à partir de valeurs par défaut directement dans le code\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "bool NoeudAbstrait::estAffiche () const\fC [inline]\fP"

.PP
Vérifie si le noeud se fait afficher\&. Cette fonction retourne l'état que le noeud se fait afficher ou non\&.
.PP
\fBReturns:\fP
.RS 4
L'état affiché ou non\&. 
.RE
.PP

.SS "bool EtatAbstrait::estClickDrag ()\fC [protected]\fP"
Cette fonction vérifie si le point d'origine et le point final d'un clique est à plus de trois pixels 
.SS "bool NoeudAbstrait::estDuplicable () const\fC [inline]\fP"

.PP
Vérifie si l'objet peut être dupliqué\&. Cette méthode retourne si oui ou non le Noeud est duplicable\&.
.PP
\fBReturns:\fP
.RS 4
L'état enregistrable ou non\&. 
.RE
.PP

.SS "bool NoeudAbstrait::estEnregistrable () const\fC [inline]\fP"

.PP
Vérifie si le noeud est enregistrable\&. Cette fonction retourne l'état d'être enregistrable en XML ou non du noeud\&.
.PP
\fBReturns:\fP
.RS 4
L'état enregistrable ou non\&. 
.RE
.PP

.SS "bool NoeudAbstrait::estSelectionnable () const\fC [inline]\fP"

.PP
Vérifie si le noeud est sélectionnable\&. Cette fonction retourne l'état d'être sélectionnable ou non du noeud\&.
.PP
\fBReturns:\fP
.RS 4
L'état sélectionnable ou non\&. 
.RE
.PP

.SS "bool NoeudAbstrait::estSelectionne () const\fC [inline]\fP"

.PP
Vérifie si le noeud est sélectionné\&. Cette fonction retourne l'état d'être sélectionné ou non du noeud\&.
.PP
\fBReturns:\fP
.RS 4
L'état sélectionné ou non\&. 
.RE
.PP

.SS "EtatAbstrait::EtatAbstrait ()"
Constructeur par défault\&. Assigne arbre_ à arbre courant 
.SS "EtatCreationLigne::EtatCreationLigne ()"
Constructeur par défault 
.SS "EtatCreationMur::EtatCreationMur ()"
Constructeur par défault 
.SS "EtatCreationPoteau::EtatCreationPoteau ()"
Constructeur par défault 
.SS "EtatDeplacement::EtatDeplacement ()"
Constructeur par défault 
.SS "EtatDuplication::EtatDuplication ()"
Constructeur par défault 
.SS "EtatMiseAEchelle::EtatMiseAEchelle ()"
Constructeur par défault 
.SS "EtatRotation::EtatRotation ()"
Constructeur par défault 
.SS "EtatSelection::EtatSelection ()"
Constructeur par défault\&. Assigne arbre_ à arbre courant 
.SS "bool BancTests::executer ()"

.PP
Exécuter tous les tests unitaires\&. Cette fonction exécute l'ensemble des tests unitaires définis\&. La sortie de l'exécution des tests se fait dans la console standard d'erreurs 'cerr'\&. Cette fonction ajuste également le format de sortie pour correspondre à celui de Visual Studio afin d'intégrer l'exécution des tests au processus de compilation ('Post Build Event')\&.
.PP
\fBReturns:\fP
.RS 4
true si l'exécution de tous les tests a réussi, sinon false\&. 
.RE
.PP

.SS "void NoeudAbstrait::fromJson (rapidjson::Value::ConstValueIterator noeudJSON)"

.PP
assigne les attributs d'un noeud à partir d'un JSON Cette fonction assigne les valeurs nécessaires au chargement du noeud à partir du fichier JSOn de sauvegarde\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeudJSON\fP : Le noeud du fichier JSON contenant les informations de chargement\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void ModeAbstrait::gererBarreDespacement ()\fC [virtual]\fP"
Cette fonction permet de gérer la barre d'espacement selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.SS "void EtatAbstrait::gererClicDroitEnfonce (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne un booléan à true si le bouton droit de la souris est appuyé\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.SS "void ModeEdition::gererClicDroitEnfonce (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction permet de gérer le clic droit enfonce dans le modeEdition\&. Elle appelle la fonction gererClicDroitEnfonce selon l'état obtenu\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP : La position en x du curseur de la souris lors d'un clic droit\&. 
.br
\fIy\fP : La position en y du curseur de la souris lors d'un clic droit\&. 
.RE
.PP

.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererClicDroitEnfonce (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction permet de gérer le clic droit enfonce selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP : La position en x du curseur de la souris lors d'un clic droit\&. 
.br
\fIy\fP : La position en y du curseur de la souris lors d'un clic droit\&. 
.RE
.PP

.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatAbstrait::gererClicDroitRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne un booléan à false si le bouton droit de la souris est relâché\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.SS "void ModeEdition::gererClicDroitRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction permet de gérer le clic droit relache dans le modeEdition\&. Elle appelle la fonction gererClicDroitRelache selon l'état obtenu\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP : La position en x du curseur de la souris lors d'un clic droit\&. 
.br
\fIy\fP : La position en y du curseur de la souris lors d'un clic droit\&. 
.RE
.PP

.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererClicDroitRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction permet de gérer le clic droit relache selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP : La position en x du curseur de la souris lors d'un clic droit\&. 
.br
\fIy\fP : La position en y du curseur de la souris lors d'un clic droit\&. 
.RE
.PP

.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatSelection::gererClicGauche (const int & x, const int & y)"
Cette fonction sélectionne un objet selon la position de la souris\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.SS "void EtatDeplacement::gererClicGaucheEnfonce (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction déplace un objet s'il est sélectionné tant que le clique gauche est enfoncé
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatRotation::gererClicGaucheEnfonce (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne un booléan à true si le bouton gauche de la souris est appuyé et sauvegarde la position courante\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationMur::gererClicGaucheEnfonce (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne un booléan à true si le bouton gauche de la souris est appuyé et sauvegarde la position courante\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationPoteau::gererClicGaucheEnfonce (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne un booléan à true si le bouton gauche de la souris est appuyé et sauvegarde la position courante\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatMiseAEchelle::gererClicGaucheEnfonce (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction sauvegarde l'emplacement du clique
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatAbstrait::gererClicGaucheEnfonce (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne un booléan à true si le bouton gauche de la souris est appuyé et sauvegarde la position courante\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented in \fBEtatCreationMur\fP, \fBEtatCreationPoteau\fP, \fBEtatMiseAEchelle\fP, \fBEtatDeplacement\fP, and \fBEtatRotation\fP\&.
.SS "void ModeEdition::gererClicGaucheEnfonce (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction permet de gérer le clic gauche enfonce dans le modeEdition\&. Elle appelle la fonction gererClicGaucheEnfonce selon l'état obtenu\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP : La position en x du curseur de la souris lors d'un clic droit\&. 
.br
\fIy\fP : La position en y du curseur de la souris lors d'un clic droit\&. 
.RE
.PP

.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererClicGaucheEnfonce (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction permet de gérer le clic gauche enfonce selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP : La position en x du curseur de la souris lors d'un clic gauche\&. 
.br
\fIy\fP : La position en y du curseur de la souris lors d'un clic gauche\&. 
.RE
.PP

.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatLoupe::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Zoom sur la zone et unzoom de la zone si la touche alt est enfoncée
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatDeplacement::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne la nouvelle position de l'objet s'il est sur la table\&. Sinon il est replacé à sa position originale\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatDuplication::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction duplique les objets sélectionnés\&. Si on objet est à l'extérieur on les remets à la position initiale\&. Si le curseur n'est pas sur la table on ne fait rien\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatRotation::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne un angle de rotation à l'objet s'il est toujours sur la table\&. Sinon il est remis à sa position initiale\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationLigne::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction crée une ligne si le curseur est sur la table et que le clique est à moins de trois pixels\&. Crée un segement de ligne si CTRL est enfoncé par la suite sinon dernière ligne créé\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationMur::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction crée un mur au premier clique puis assigne son facteur de mise à échelle et angle de rotation en fonction du deuxième clique\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationPoteau::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne un booléan à false si le bouton gauche de la souris est relâché et crée un poteau sur la table
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatMiseAEchelle::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne le facteur mise à échelle si l'objet est encore dans la zone de création\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatSelection::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction arrète l'affichage du rectangle élastique et génère un clique gauche sur tous les objets dans le rectangle\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatAbstrait::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne un booléan à false si le bouton gauche de la souris est relâché\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented in \fBEtatSelection\fP, \fBEtatCreationLigne\fP, \fBEtatCreationMur\fP, \fBEtatCreationPoteau\fP, \fBEtatMiseAEchelle\fP, \fBEtatDeplacement\fP, \fBEtatDuplication\fP, \fBEtatRotation\fP, and \fBEtatLoupe\fP\&.
.SS "void ModeEdition::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction permet de gérer le clic gauche relache dans le modeEdition\&. Elle appelle la fonction gererClicGaucheRelache selon l'état obtenu\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP : La position en x du curseur de la souris lors d'un clic droit\&. 
.br
\fIy\fP : La position en y du curseur de la souris lors d'un clic droit\&. 
.RE
.PP

.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererClicGaucheRelache (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction permet de gérer le clic gauche relache selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP : La position en x du curseur de la souris lors d'un clic gauche\&. 
.br
\fIy\fP : La position en y du curseur de la souris lors d'un clic gauche\&. 
.RE
.PP

.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatSelection::gererDragGauche (const int & xAvant, const int & yAvant, const int & xApres, const int & yApres)"
Cette fonction crée un rectangle élastique selon la position x et y du début du drag et x et y a la fin\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& xAvant: Position initiale en x  int& yAvant: Position initiale en y  int& xApres: Position finale en x  int& yApres: Position finale en y 
.RE
.PP

.SS "void ModeEdition::gererFlecheBas ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche flèche bas dans le modeEdition\&.
.PP
Fait un déplacement de 10 pixels selon l'axe des y\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererFlecheBas ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche flèche bas selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererFlecheDroit ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche flèche droit dans le modeEdition\&.
.PP
Fait un déplacement de -10 pixels selon l'axe des x\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererFlecheDroit ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche flèche droit selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererFlecheGauche ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche flèche gauche dans le modeEdition\&.
.PP
Fait un déplacement de 10 pixels selon l'axe des x\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererFlecheGauche ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche flèche gauche selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererFlecheHaut ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche flèche haut dans le modeEdition\&.
.PP
Fait un déplacement de -10 pixels selon l'axe des y\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererFlecheHaut ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche flèche haut selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatAbstrait::gererMoletteSouris (const int & delta)\fC [virtual]\fP"
Cette fonction gère la molette de la souris\&. Permet d'effecter un zoom avec la caméra
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int & delta: la valeur de la molette de la souris 
.RE
.PP

.SS "void ModeEdition::gererMoletteSouris (const int & delta)\fC [virtual]\fP"
Cette fonction permet de gérer la molette de le souris dans le modeEdition\&.
.PP
Selon le signe du delta, nous ferons un zoom in ou out\&.
.PP
\fBParameters:\fP
.RS 4
\fIdelta\fP : La différence entre du mouvement de molette de la souris\&. 
.RE
.PP

.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererMoletteSouris (const int & delta)\fC [virtual]\fP"
Cette fonction permet de gérer la molette de le souris selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&.
.PP
\fBParameters:\fP
.RS 4
\fIdelta\fP : La différence entre du mouvement de molette de la souris\&. 
.RE
.PP

.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatLoupe::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Crée un rectangle élastique si le bouton gauche est appuyé sinon rien
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatDeplacement::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction change les attributs de position X et Y d'un objet en fonction de la position du curseur
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatDuplication::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne la position en x et y courante à la duplication\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatRotation::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction change l'attribut angle de rotation avec le position en y de la souris lorsque le clique gauche est appuyé\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationLigne::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne la longeur et l'angle d'une ligne lorsqu'elle est en création, sinon rien
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationMur::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction assigne un facteur de mise à échelle et un angle de rotation à un mur s'il est en création\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationPoteau::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction gère les mouvements de la souris\&. Si le clique droit est enfoncé on peux déplacer la caméra, sinon rien
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatMiseAEchelle::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction change le facteur de dimension en fonction de la position actuelle de la souris\&. Si le bouton gauche n'est pas appuyé, rien\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatSelection::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction affiche un rectangle élastique si le clique gauche est appuyé\&. Sinon elle ne fait rien\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatAbstrait::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction gère les mouvements de la souris\&. Si le clique droit est enfoncé on peux déplacer la caméra, sinon rien
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP int& x: position en x du cursor 
.br
\fIconst\fP int& y: position en y du cursor 
.RE
.PP

.PP
Reimplemented in \fBEtatSelection\fP, \fBEtatCreationLigne\fP, \fBEtatCreationMur\fP, \fBEtatCreationPoteau\fP, \fBEtatMiseAEchelle\fP, \fBEtatDeplacement\fP, \fBEtatDuplication\fP, \fBEtatRotation\fP, and \fBEtatLoupe\fP\&.
.SS "void ModeEdition::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction permet de gérer le mouvement de souris dans le modeEdition\&. Elle appelle la fonction gererMouvementSouris selon l'état obtenu\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP : La position en x du curseur de la souris lors d'un mouvement de souris\&. 
.br
\fIy\fP : La position en y du curseur de la souris lors d'un mouvement de souris\&. 
.RE
.PP

.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererMouvementSouris (const int & x, const int & y)\fC [virtual]\fP"
Cette fonction permet de gérer le mouvement de la souris selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP : La position en x du curseur de la souris lors d'un mouvement de souris\&. 
.br
\fIy\fP : La position en y du curseur de la souris lors d'un mouvement de souris\&. 
.RE
.PP

.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatAbstrait::gererPositionCurseur (const glm::dvec3 & position)"
Cette fonction vérifie que le curseur est sur la table et appel la méthode concrète\&.
.PP
\fBParameters:\fP
.RS 4
\fIconst\fP glm::dvec3& position: position de la souris 
.RE
.PP

.SS "void EtatDuplication::gererPositionCurseurConcret (const bool & positionEstSurTable)\fC [virtual]\fP"
Implémentation concrète de la gestion de la position du curseur\&. Il s'agit d'une méthode implémentée par les classes dérivées\&.
.PP
\fBParameters:\fP
.RS 4
\fIbool\fP positionEstSurTable: True si la souris est sur la table sinon false 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationPoteau::gererPositionCurseurConcret (const bool & positionEstSurTable)\fC [virtual]\fP"
Implémentation concrète de la gestion de la position du curseur\&. Il s'agit d'une méthode implémentée par les classes dérivées\&.
.PP
\fBParameters:\fP
.RS 4
\fIbool\fP positionEstSurTable: True si la souris est sur la table sinon false 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationMur::gererPositionCurseurConcret (const bool & positionEstSurTable)\fC [virtual]\fP"
Cette fonction affiche l'objet si le curseur est sur la table et arrête d'afficher l'objet si le curseur n'est pas sur la table\&.
.PP
\fBParameters:\fP
.RS 4
\fIbool\fP positionEstSurTable: True si curseur est sur la table, sinon false\&. 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationLigne::gererPositionCurseurConcret (const bool & positionEstSurTable)\fC [virtual]\fP"
Implémentation concrète de la gestion de la position du curseur\&. Il s'agit d'une méthode implémentée par les classes dérivées\&.
.PP
\fBParameters:\fP
.RS 4
\fIbool\fP positionEstSurTable: True si la souris est sur la table sinon false 
.RE
.PP

.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatAbstrait::gererPositionCurseurConcret (const bool & positionEstSurTable)\fC [virtual]\fP"
Implémentation concrète de la gestion de la position du curseur\&. Il s'agit d'une méthode implémentée par les classes dérivées\&.
.PP
\fBParameters:\fP
.RS 4
\fIbool\fP positionEstSurTable: True si la souris est sur la table sinon false 
.RE
.PP

.PP
Reimplemented in \fBEtatCreationLigne\fP, \fBEtatCreationMur\fP, \fBEtatCreationPoteau\fP, and \fBEtatDuplication\fP\&.
.SS "void ModeEdition::gererTouche1 ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche 1 dans le modeEdition\&.
.PP
Ne fait rien dans ce mode\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererTouche1 ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche 1 selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererTouche2 ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche 2 dans le modeEdition\&.
.PP
Ne fait rien dans ce mode\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererTouche2 ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche 2 selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeAbstrait::gererTouche3 ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche 3 selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.SS "void ModeEdition::gererToucheAltEnfoncee ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche ALT enfoncee dans le modeEdition\&. Elle appelle la fonction gererToucheAltEnfoncee selon l'état obtenu\&. 
.SS "void EtatAbstrait::gererToucheAltEnfoncee ()\fC [virtual]\fP"
Cette fonction gère la touche Alt enfoncee 
.SS "void ModeEdition::gererToucheAltRelachee ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche ALT relachee dans le modeEdition\&. Elle appelle la fonction gererToucheAltRelachee selon l'état obtenu\&. 
.SS "void EtatAbstrait::gererToucheAltRelachee ()\fC [virtual]\fP"
Cette fonction gère la touche Alt relâchée 
.SS "void ModeAbstrait::gererToucheArriere ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche arrière selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.SS "void ModeAbstrait::gererToucheB ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche B selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.SS "void ModeEdition::gererToucheC ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche C dans le modeEdition\&.
.PP
Elle assigne l'état DUPLICATION à l'instance obtenue\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheC ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche C selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatCreationLigne::gererToucheControlEnfoncee ()\fC [virtual]\fP"
Cette fonction assigne la valeur True si la touche CTRL est enfoncée 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatSelection::gererToucheControlEnfoncee ()\fC [virtual]\fP"
Cette fonction gère la touche Control relâchée 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void ModeEdition::gererToucheControlEnfoncee ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche CTRL enfoncee dans le modeEdition\&.
.PP
Elle appelle la fonction gererToucheControlEnfoncee selon l'état obtenu\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void EtatAbstrait::gererToucheControlEnfoncee ()\fC [virtual]\fP"
Cette fonction gère la touche Control enfoncee 
.PP
Reimplemented in \fBEtatSelection\fP, and \fBEtatCreationLigne\fP\&.
.SS "void ModeAbstrait::gererToucheControlEnfoncee ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche CTRL enfoncée selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatCreationLigne::gererToucheControlRelachee ()\fC [virtual]\fP"
Cette fonction assigne la valeur False si la touche CTRL est relâchée 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatSelection::gererToucheControlRelachee ()\fC [virtual]\fP"
Cette fonction gère la touche Control relâchée 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void ModeEdition::gererToucheControlRelachee ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche CTRL relachee dans le modeEdition\&.
.PP
Elle appelle la fonction gererToucheControlRelachee selon l'état obtenu\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void EtatAbstrait::gererToucheControlRelachee ()\fC [virtual]\fP"
Cette fonction gère la touche Control relâchée 
.PP
Reimplemented in \fBEtatSelection\fP, and \fBEtatCreationLigne\fP\&.
.SS "void ModeAbstrait::gererToucheControlRelachee ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche CTRL relachée selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererToucheCTRLavecN ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche CTRL avec N dans le modeEdition\&.
.PP
Ne fait rien dans ce mode\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheCTRLavecN ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche CTRL avec N selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererToucheCTRLavecO ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche O dans le modeEdition\&.
.PP
Ne fait rien dans ce mode\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheCTRLavecO ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche CTRL avec O selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererToucheCTRLavecS ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche CTRL avec S dans le modeEdition\&.
.PP
Ne fait rien dans ce mode\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheCTRLavecS ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche CTRL avec S selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererToucheD ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche D dans le modeEdition\&.
.PP
Elle assigne l'état DEPLACEMENT à l'instance obtenue\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheD ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche D selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererToucheE ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche E dans le modeEdition\&.
.PP
Elle assigne l'état MISE_A_ECHELLE à l'instance obtenue\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheE ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche E selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatCreationLigne::gererToucheEchappe ()\fC [virtual]\fP"
Cette fonction supprime une ligne si elle est en création\&. Sinon rien 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatCreationMur::gererToucheEchappe ()\fC [virtual]\fP"
Cette fonction supprime le mur s'il est en création 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void ModeEdition::gererToucheEchappe ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche echappe selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheEchappe ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche echappe selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatAbstrait::gererToucheEchappe ()\fC [virtual]\fP"
Cette fonction gère la touche Escape 
.PP
Reimplemented in \fBEtatCreationLigne\fP, and \fBEtatCreationMur\fP\&.
.SS "void ModeAbstrait::gererToucheJ ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche J selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.SS "void ModeAbstrait::gererToucheK ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche K selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.SS "void ModeAbstrait::gererToucheL ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche L selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.SS "void ModeEdition::gererToucheMoins ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche - dans le modeEdition\&.
.PP
Si nous ne sommes pas en perspective, la touche plus effectue un zoom out\&.
.PP
Cette fonction permet de gérer la touche echappe dans le modeEdition\&.
.PP
Elle appelle la fonction gereToucheEchappe selon l'état obtenu\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheMoins ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche - selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatAbstrait::gererToucheMoins ()\fC [virtual]\fP"
Cette fonction gère la touche -=, permet de faire un zoom arrière\&. 
.SS "void ModeEdition::gererTouchePlus ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche + dans le modeEdition\&.
.PP
Si nous ne sommes pas en perspective, la touche plus effectue un zoom in\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererTouchePlus ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche + selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void EtatAbstrait::gererTouchePlus ()\fC [virtual]\fP"
Cette fonction gère la touche +=, permet de faire un zoom avant\&. 
.SS "void ModeEdition::gererToucheR ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche R dans le modeEdition\&.
.PP
Elle assigne l'état ROTATION à l'instance obtenue\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheR ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche R selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererToucheS ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche S dans le modeEdition\&.
.PP
Elle assigne l'état SELECTION à l'instance obtenue\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheS ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche S selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererToucheSupprimer ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche supprimer dans le modeEdition\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheSupprimer ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche supprimer selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererToucheT ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche T dans le modeEdition\&.
.PP
Elle assigne le mode TEST à l'instance obtenue\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheT ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche T selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::gererToucheZ ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche Z dans le modeEdition\&.
.PP
Elle assigne l'état ZOOM à l'instance obtenue\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "void ModeAbstrait::gererToucheZ ()\fC [virtual]\fP"
Cette fonction permet de gérer la touche Z selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "std::shared_ptr< const \fBNoeudAbstrait\fP > NoeudComposite::getEnfant (int indice) const"
Retourne un std::shared_ptr<const NoeudAbstrait>
.PP
\fBParameters:\fP
.RS 4
\fIint\fP : Indice du noeud enfant\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Le noeud a l'indice donne 
.RE
.PP

.SS "\fBNoeudComposite::conteneur_enfants\fP & NoeudComposite::getEnfants ()"
Retourne le conteneur des enfants de ce noeud
.PP
\fBReturns:\fP
.RS 4
conteneur_enfants: Le conteneur d'enfants de ce Noeud\&. 
.RE
.PP

.SS "modele::Modele3D const * NoeudAbstrait::getModele ()\fC [virtual]\fP"

.PP
Retourne le modèle\&. Cette fonction retourne le modele 3D utilisé pour représenté l'instance concrète du Noeud\&.
.PP
Elle ne fait rien pour cette classe et vise à être surcharger par les classes dérivées\&.
.PP
\fBReturns:\fP
.RS 4
Le modèle 3D du noeud, null si absent\&. 
.RE
.PP

.SS "void VisiteurMiseAEchelle::initialiser (\fBArbreRendu\fP * noeud)"
Fonction qui initialise les valeurs du vecteur facteursDimensionsInitiaux_ selon les facteurs de dimensions des enfants de la table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : l'arbre rendu contenant le noeud Table, entre autres\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void ArbreRenduINF2990::initialiser ()"

.PP
Initialise l'arbre de rendu à son état initial\&. Cette fonction appel chargerZoneDefaut() pour créer la structure de base de l'arbre de rendu, c'est-à-dire avec les noeuds structurants (pour les objets, les murs, les billes, les parties statiques, etc\&.)\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "public void InterfaceGraphique\&.Window\&.InitialiserAnimation ()\fC [inline]\fP"
Cette fonction initialize les animations sur le viewPort_ panel 
.SS "void FacadeModele::initialiserOpenGL (HWND hWnd)"

.PP
Crée un contexte OpenGL et initialise celui-ci\&. Cette fonction permet d'initialiser le contexte OpenGL\&. Elle crée un contexte OpenGL sur la fenêtre passée en paramètre, initialise FreeImage (utilisée par le chargeur de modèles) et assigne des paramètres du contexte OpenGL\&.
.PP
\fBParameters:\fP
.RS 4
\fIhWnd\fP : La poignée ('handle') vers la fenêtre à utiliser\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP
Pour normaliser les normales dans le cas d'utilisation de glScale[fd] 
.SS "void NoeudAbstrait::inverserSelection ()\fC [virtual]\fP"

.PP
Changer la sélection du noeud\&. Cette fonction inverse l'état de sélection de ce noeud\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void FacadeModele::libererInstance ()\fC [static]\fP"

.PP
Libère l'instance unique de la classe\&. Cette fonction libère l'instance unique de cette classe\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void FacadeModele::libererOpenGL ()"

.PP
Libère le contexte OpenGL\&. Cette fonction libère le contexte OpenGL et désinitialise FreeImage\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void ConfigScene::lireDOM (tinyxml2::XMLDocument const & document)"

.PP
Lire les valeurs du DOM\&. Cette fonction lit les valeurs de la configuration à partir d'un élément XML\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "public void InterfaceGraphique\&.Window\&.MettreAJour (double tempsInterAffichage)\fC [inline]\fP"
Cette fonction met a jour l'animation de viewPort_ panel
.PP
\fBParameters:\fP
.RS 4
\fIdouble\fP tempsInterAffichage: Temps entre chaque affichage 
.RE
.PP

.SS "ModeAbstrait::ModeAbstrait ()"
Contructeur (vide) par défaut de \fBModeAbstrait\fP 
.SS "ModeConfigure::ModeConfigure ()"
Constructeur par défaut pour le mode configure 
.SS "ModeEdition::ModeEdition ()"
Ne fait qu'initialiser les variables membres de la classe\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "ModeMenuPrincipal::ModeMenuPrincipal ()"
Constructeur par défaut pour le mode du menu principal 
.SS "ModeSimulation::ModeSimulation ()"
Constructeur par défaut pour le mode simulation 
.SS "ModeTest::ModeTest ()"
Constructeur par défaut pour le mode test 
.SS "NoeudAbstrait::NoeudAbstrait (const std::string & type = \fCstd::string{ '' }\fP)"

.PP
Constructeur\&. Ne fait qu'initialiser les variables membres de la classe\&.
.PP
\fBParameters:\fP
.RS 4
\fItype\fP : Le type du noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "NoeudComposite::NoeudComposite (const std::string & type = \fCstd::string{ '' }\fP)"

.PP
Constructeur\&. Ne fait qu'appeler la version de la classe de base\&.
.PP
\fBParameters:\fP
.RS 4
\fItype\fP : Le type du noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "NoeudDepart::NoeudDepart (const std::string & typeNoeud)"

.PP
Constructeur à partir du type du noeud\&. Ce constructeur ne fait qu'appeler la version de la classe et base et donner des valeurs par défaut aux variables membres\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "NoeudDuplication::NoeudDuplication (const std::string & typeNoeud)"

.PP
Constructeur\&. Ce constructeur ne fait qu'appeler la version de la classe et base et donner des valeurs par défaut aux variables membres\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "NoeudLigne::NoeudLigne (const std::string & typeNoeud)"

.PP
Constructeur\&. Ce constructeur ne fait qu'appeler la version de la classe et base et donner des valeurs par défaut aux variables membres\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "NoeudMur::NoeudMur (const std::string & typeNoeud)"

.PP
Constructeur\&. Ce constructeur ne fait qu'appeler la version de la classe et base et donner des valeurs par défaut aux variables membres\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "NoeudPoteau::NoeudPoteau (const std::string & typeNoeud)"

.PP
Constructeur\&. Ce constructeur ne fait qu'appeler la version de la classe et base et donner des valeurs par défaut aux variables membres\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "NoeudRobot::NoeudRobot (const std::string & typeNoeud)"

.PP
Constructeur à partir du type du noeud\&. Ce constructeur ne fait qu'appeler la version de la classe et base et donner des valeurs par défaut aux variables membres\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "NoeudSegment::NoeudSegment (const std::string & typeNoeud)"

.PP
Constructeur\&. Ce constructeur ne fait qu'appeler la version de la classe et base et donner des valeurs par défaut aux variables membres\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "NoeudTable::NoeudTable (const std::string & typeNoeud)"

.PP
Constructeur\&. Ce constructeur ne fait qu'appeler la version de la classe et base et donner des valeurs par défaut aux variables membres\&.
.PP
\fBParameters:\fP
.RS 4
\fItypeNoeud\fP : Le type du noeud\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "bool VisiteurVerificationQuad::objetsDansZoneSimulation ()\fC [inline]\fP"

.PP
Obtenir si tous les objets sont dans la zone de simulation\&. Retourne l'attribut objetsDansZoneSimulation_ indiquant si les objets sont dans les limites de la table\&.
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
bool : Booléen qui indique si les objets sont dans les limites de la table\&. 
.RE
.PP

.SS "double FacadeModele::obtenirAngleRotation ()"
Cette fonction permet d'obtenir l'angle de rotation d'un objet
.PP
\fBReturns:\fP
.RS 4
doublee : l'angle de rotation de l'objet 
.RE
.PP

.SS "\fBArbreRenduINF2990\fP * FacadeModele::obtenirArbreRenduINF2990 () const\fC [inline]\fP"

.PP
Retourne l'arbre de rendu\&. Cette fonction retourne l'arbre de rendu de la scène (version constante de la fonction)\&.
.PP
\fBReturns:\fP
.RS 4
L'arbre de rendu de la scène\&. 
.RE
.PP

.SS "\fBArbreRenduINF2990\fP * FacadeModele::obtenirArbreRenduINF2990 ()\fC [inline]\fP"

.PP
Retourne l'arbre de rendu\&. Cette fonction retourne l'arbre de rendu de la scène (version non constante de la fonction)\&.
.PP
\fBReturns:\fP
.RS 4
L'arbre de rendu de la scène\&. 
.RE
.PP

.SS "std::string ArbreRendu::obtenirCheminFichierZoneDefaut ()"

.PP
Retourne le chemin vers le fichier de zone de base\&. Fonction permettant d'obtenir le chemin vers le fichier contenant la structure de base de l'arbre de rendu\&.
.PP
\fBReturns:\fP
.RS 4
Pointeur vers le fichier 
.RE
.PP

.SS "\fBNoeudAbstrait\fP * VisiteurDuplication::obtenirDuplication ()\fC [inline]\fP"
Retourne l'attribut duplication_ qui représente le noeud dupliqué\&.
.PP
\fBParameters:\fP
.RS 4
\fIAucun\&.\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
NoeudAbstrait* : noeud dupliqué\&. 
.RE
.PP

.SS "bool VisiteurAbstrait::obtenirEstDrag ()\fC [inline]\fP"
Fonction qui retrourne l'attribut estDrag qui indique s'il s'agit d'un drag ou d'un simple clic\&.
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "\fBEtatAbstrait\fP * FacadeModele::obtenirEtat ()\fC [inline]\fP"
Cette fonction retourne l'état dans lequel se trouve présentement le modèle\&.
.PP
\fBReturns:\fP
.RS 4
L'état courant\&. 
.RE
.PP

.SS "double NoeudAbstrait::obtenirFacteurMiseAEchelle () const\fC [inline]\fP"

.PP
Obtient le facteur de dimension du noeud\&. Cette fonction permet d'obtenir l'échelle d'agrandissement ou de rapetissement du noeud\&.
.PP
\fBReturns:\fP
.RS 4
L'échelle de l'objet\&. 1 étant l'échelle originale\&. 
.RE
.PP

.SS "FILE * ArbreRendu::obtenirFichierZone (std::string mode)"

.PP
Retourne un pointeur vers le fichier sélectionné par l'utilisateur\&. Fonction permettant d'obtenir le fichier de zone sélectionné par l'utilisateur\&.
.PP
\fBParameters:\fP
.RS 4
\fImode\fP : Si on ouvre le fichier en lecture ou en écriture\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Pointeur vers le fichier 
.RE
.PP

.SS "FILE * ArbreRendu::obtenirFichierZoneDefaut (std::string mode)\fC [protected]\fP"

.PP
Retourne un pointeur vers le fichier de structure de base\&. Fonction permettant d'obtenir le fichier de zone contenant la structure de base\&.
.PP
\fBParameters:\fP
.RS 4
\fImode\fP : Si on ouvre le fichier en lecture ou en écriture\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Pointeur vers le fichier 
.RE
.PP

.SS "\fBFacadeModele\fP * FacadeModele::obtenirInstance ()\fC [static]\fP"

.PP
Obtient l'instance unique de la classe\&. Cette fonction retourne un pointeur vers l'instance unique de la classe\&. Si cette instance n'a pas été créée, elle la crée\&. Cette création n'est toutefois pas nécessairement 'thread-safe', car aucun verrou n'est pris entre le test pour savoir si l'instance existe et le moment de sa création\&.
.PP
\fBReturns:\fP
.RS 4
Un pointeur vers l'instance unique de cette classe\&. 
.RE
.PP

.SS "\fBModeAbstrait\fP * FacadeModele::obtenirMode ()\fC [inline]\fP"
Cette fonction retourne le mode dans lequel se trouve présentement le modèle\&.
.PP
\fBReturns:\fP
.RS 4
le mode courant\&. 
.RE
.PP

.SS "unsigned int NoeudComposite::obtenirNombreEnfants () const\fC [virtual]\fP"

.PP
Obtient le nombre d'enfants du noeud\&. Retourne le nombre d'enfants directement sous ce noeud\&. Elle ne donne pas le nombre total de descendants, mais bien le nombre de ceux qui sont directement sous ce noeud\&.
.PP
\fBReturns:\fP
.RS 4
Le nombre d'enfants directement sous ce noeud\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "unsigned int NoeudAbstrait::obtenirNombreEnfants () const\fC [virtual]\fP"

.PP
Obtient le nombre d'enfants du noeud\&. Cette fonction retourne le nombre d'enfants de ce noeud\&.
.PP
Elle retourne toujours 0, car ce type de noeud abstrait ne peut pas avoir d'enfant\&.
.PP
\fBReturns:\fP
.RS 4
Le nombre d'enfants que possède le noeud\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "int FacadeModele::obtenirNombreSelection ()"
Cette fonction permet d'obtenir le nombre d'objet selectionné
.PP
\fBReturns:\fP
.RS 4
int : le nombre d'objet selectionné 
.RE
.PP

.SS "\fBNoeudAbstrait\fP * NoeudAbstrait::obtenirParent ()\fC [inline]\fP"

.PP
Obtient le parent de ce noeud\&. Cette fonction retourne le pointeur vers le parent de ce noeud\&.
.PP
\fBReturns:\fP
.RS 4
Le pointeur vers le parent\&. 
.RE
.PP

.SS "const \fBNoeudAbstrait\fP * NoeudAbstrait::obtenirParent () const\fC [inline]\fP"

.PP
Obtient le parent de ce noeud (version constante)\&. Cette fonction retourne le pointeur constant vers le parent de ce noeud\&.
.PP
\fBReturns:\fP
.RS 4
Le pointeur constant vers le parent\&. 
.RE
.PP

.SS "const glm::dvec3 & NoeudAbstrait::obtenirPositionRelative () const\fC [inline]\fP"

.PP
Obtient la position relative du noeud\&. Cette fonction retourne la position relative du noeud par rapport à son parent\&.
.PP
\fBReturns:\fP
.RS 4
La position relative\&. 
.RE
.PP

.SS "double FacadeModele::obtenirPositionRelativeX ()"
Cette fonction permet d'obtenir la position relative en X
.PP
\fBReturns:\fP
.RS 4
doublee : la position relative en X 
.RE
.PP

.SS "double FacadeModele::obtenirPositionRelativeY ()"
Cette fonction permet d'obtenir la position relative en Y
.PP
\fBReturns:\fP
.RS 4
doublee : la position relative en Y 
.RE
.PP

.SS "utilitaire::QuadEnglobant NoeudAbstrait::obtenirQuadEnglobantCourant () const\fC [inline]\fP"

.PP
Obtient le quadrilatère englobant du noeud\&. Cette fonction permet d'obtenir le quad définisant la zone de sélection de l'objet\&.
.PP
\fBReturns:\fP
.RS 4
Un plan orthogonal à Z représentant les bornes de l'objet dans l'espace 3d\&. 
.RE
.PP

.SS "utilitaire::QuadEnglobant NoeudAbstrait::obtenirQuadEnglobantModele () const\fC [inline]\fP"

.PP
Obtenir la boite englobante du modèle\&. Cette fonction permet d'obtenir le quad définit en fonction du modele\&.
.PP
\fBReturns:\fP
.RS 4
Un plan orthogonal à Z représentant les bornes de l'objet dans l'espace 3d\&. 
.RE
.PP

.SS "\fBNoeudAbstrait\fP * VisiteurAbstrait::obtenirReferenceNoeud ()\fC [inline]\fP"
Fonction qui retourne la référence d'un noeud
.PP
\fBParameters:\fP
.RS 4
\fIAucun\&.\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
NoeudAbstrait* : le noeud dont on veut la référence\&. 
.RE
.PP

.SS "const std::string & NoeudAbstrait::obtenirType () const\fC [inline]\fP"

.PP
Obtient le type du noeud\&. Cette fonction retourne une chaîne représentante le type du noeud\&.
.PP
\fBReturns:\fP
.RS 4
Le type du noeud\&. 
.RE
.PP

.SS "int ModeAbstrait::obtenirTypeMode ()\fC [inline]\fP"
Cette fonction retourne le type de mode de l'attribut typeMode_\&.
.PP
\fBReturns:\fP
.RS 4
int typeMode_\&. 
.RE
.PP

.SS "vue::Vue * FacadeModele::obtenirVue ()\fC [inline]\fP"

.PP
Retourne la vue courante\&. Cette fonction retourne la vue qui est présentement utilisée pour voir la scène\&.
.PP
\fBReturns:\fP
.RS 4
La vue courante\&. 
.RE
.PP

.SS "public InterfaceGraphique\&.PopOutInterface\&.PopOutInterface ()\fC [inline]\fP"
Cette fonction initialize le popout et lui assigne un text sur son label 
.SS "bool VisiteurSelection::quadEstDansRectangleElastique (const utilitaire::QuadEnglobant & quad)"
Fonction qui sélectionne les objets du noeud Table passé en paramètre selon la position du curseur et selon l'état de la touche Ctrl\&.
.PP
\fBParameters:\fP
.RS 4
\fIquad\fP : La boîte englobante à laquelle on veut appliquer la sélection\&.
.RE
.PP
\fBReturns:\fP
.RS 4
bool : Booléen qui indique si le quadrilatère se trouve dans le rectangle élastique ou non\&. 
.RE
.PP

.SS "void EtatDeplacement::reinitialiser ()\fC [protected]\fP, \fC [virtual]\fP"
Cette fonction remet les attributs initials à un objet 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void EtatRotation::reinitialiser ()\fC [protected]\fP, \fC [virtual]\fP"
Remet l'objet à sson angle original\&. 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void VisiteurMiseAEchelle::reinitialiser (\fBArbreRendu\fP * noeud)"
Fonction qui reinitialise les facteurs de dimensions des enfants de la table selon le vecteur facteursDimensionsInitiaux_\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : l'arbre rendu contenant le noeud Table, entre autres\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void EtatMiseAEchelle::reinitialiser ()\fC [protected]\fP, \fC [virtual]\fP"
Remet l'objet à sa dimension originale 
.PP
Reimplemented from \fBEtatAbstrait\fP\&.
.SS "void FacadeModele::reinitialiser ()"

.PP
Réinitialise la scène\&. Cette fonction réinitialise la scène à un état 'vide'\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void ModeAbstrait::sauvegarder ()\fC [virtual]\fP"
Cette fonction permet de gérer la sauvegarde selon le mode dans lequel nous sommes\&.
.PP
Il n'y a pas d'implantantion dans cette classe de base\&. 
.PP
Reimplemented in \fBModeEdition\fP\&.
.SS "void ModeEdition::sauvegarder ()\fC [virtual]\fP"
Cette fonction permet de gérer la sauvegarde dans le modeEdition\&.
.PP
Cette fonction permet de gérer le chargement dans le modeEdition\&. 
.PP
Reimplemented from \fBModeAbstrait\fP\&.
.SS "bool NoeudComposite::selectionExiste () const\fC [virtual]\fP"

.PP
Vérifier si le noeud ou un de ses enfants est sélectionné\&. Vérifie si le noeud ou un de ses descendants est sélectionné en s'appelant de manière récursive sur les enfants du noeud\&.
.PP
\fBReturns:\fP
.RS 4
Vrai s'il existe un noeud sélectionné, faux autrement\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "bool NoeudAbstrait::selectionExiste () const\fC [virtual]\fP"

.PP
Vérifier si le noeud ou un de ses enfants est sélectionné\&. Cette fonction vérifie si le noeud ou un de ses enfants est sélectionné\&.
.PP
Elle ne fait que regarder si le noeud est sélectionné, car ce type de noeud abstrait ne peut pas avoir d'enfants\&.
.PP
\fBReturns:\fP
.RS 4
Vrai s'il existe un noeud sélectionné, faux autrement\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "void NoeudComposite::selectionnerTout ()\fC [virtual]\fP"

.PP
Sélectionne tous les enfants de même que le noeud\&. Sélectionne tous les noeuds qui sont sélectionnés parmis les les descendants de ce noeud, lui-même étant inclus\&.
.PP
\fBReturns:\fP
.RS 4
Aucune 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void NoeudAbstrait::selectionnerTout ()\fC [virtual]\fP"

.PP
Sélectionne tous les enfants de même que le noeud\&. Cette fonction sélectionne le noeud et ses enfants\&.
.PP
Elle ne fait que sélectionner le noeud pour cette classe, car ce type de noeud abstrait ne peut pas avoir d'enfants\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "void ConfigSceneTest::setUp ()"

.PP
Traitement à effectuer pour initialiser cette suite de tests\&. Effectue l'initialisation préalable à l'exécution de l'ensemble des cas de tests de cette suite de tests (si nécessaire)\&.
.PP
Si certains objets doivent être construits, il est conseillé de le faire ici\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstraitTest::setUp ()"

.PP
Traitement à effectuer pour initialiser cette suite de tests\&. Effectue l'initialisation préalable à l'exécution de l'ensemble des cas de tests de cette suite de tests (si nécessaire)\&.
.PP
Si certains objets doivent être construits, il est conseillé de le faire ici\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void FacadeModele::stopAffichage ()"
Cette fonction assigne la valeur d'un booléan à false si l'on veut arrêter d'afficher l'animation 
.SS "void ConfigSceneTest::tearDown ()"

.PP
Traitement à effectuer pour 'finaliser' cette suite de tests\&. Effectue les opérations de finalisation nécessaires suite à l'exécution de l'ensemble des cas de tests de cette suite de tests (si nécessaire)\&.
.PP
Si certains objets ont été alloués à l'initialisation, ils doivent être désalloués, et il est conseillé de le faire ici\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstraitTest::tearDown ()"

.PP
Traitement à effectuer pour 'finaliser' cette suite de tests\&. Effectue les opérations de finalisation nécessaires suite à l'exécution de l'ensemble des cas de tests de cette suite de tests (si nécessaire)\&.
.PP
Si certains objets ont été alloués à l'initialisation, ils doivent être désalloués, et il est conseillé de le faire ici\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstraitTest::testEnfants ()"

.PP
Cas de test: s'assurer que le noeud abstrait n'a pas d'enfant\&. Cas de test: s'assurer que le noeud abstrait n'a pas d'enfant
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstraitTest::testPositionRelative ()"

.PP
Cas de test: écriture/lecture de la position relative\&. Cas de test: écriture/lecture de la position relative
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void ConfigSceneTest::testSauvegardeChargement ()"

.PP
Cas de test: sauvegarde et chargement XML de la configuration\&. Cas de test: sauvegarde et chargement XML de la configuration Modifier la valeur CALCULS_PAR_IMAGE, enregistrer la configuration, restaurer la valeur CALCULS_PAR_IMAGE, charger la configuration, s'assurer que la valeur sauvegardée a bien été restaurée du fichier XML, restaurer la valeur par défaut\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstraitTest::testSelection ()"

.PP
Cas de test: définition/obtention des états de sélection du noeud\&. Cas de test: définition/obtention des états de sélection du noeud
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstraitTest::testType ()"

.PP
Cas de test: type de noeud\&. Cas de test: type de noeud
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudAbstrait::toJson (rapidjson::Writer< rapidjson::FileWriteStream > & writer)"

.PP
convertit un noeud en JSON Cette fonction obtient les valeurs à sauvegarder pour le noeud en JSON
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP : Le stream dans lequel le JSON est écrit
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "void NoeudComposite::vider ()\fC [virtual]\fP"

.PP
Vide le noeud de ses enfants\&. Cette fonction vide le noeud de tous ses enfants\&. Elle effectue une itération prudente sur les enfants afin d'être assez robuste pour supporter la possibilité qu'un enfant en efface un autre dans son destructeur, par exemple si deux objets ne peuvent pas exister l'un sans l'autre\&. Elle peut toutefois entrer en boucle infinie si un enfant ajoute un nouveau noeud lorsqu'il se fait effacer\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBNoeudAbstrait\fP\&.
.SS "void NoeudAbstrait::vider ()\fC [virtual]\fP"

.PP
Vide le noeud de ses enfants\&. Cette fonction vide le noeud de tous ses enfants\&.
.PP
Cette fonction ne fait rien pour un noeud sans enfant, elle ne fait donc rien dans cette implantation par défaut de la classe de base\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBNoeudComposite\fP\&.
.SS "void VisiteurDeplacement::visiter (\fBArbreRendu\fP * noeud)\fC [virtual]\fP"
Fonction servant à donner l'accès au noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : l'arbre rendu contenant le noeud Table, entre autres\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurRotation::visiter (\fBArbreRendu\fP * noeud)\fC [virtual]\fP"
Fonction servant à donner l'accès au noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : l'arbre rendu contenant le noeud Table, entre autres\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurCreationPoteau::visiter (\fBArbreRendu\fP * noeud)\fC [virtual]\fP"

.PP
Creation de poteau sur l'arbre de rendu\&. Fonction servant à donner l'accès au noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : l'arbre rendu contenant le noeud Table, entre autres\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurDeplacement::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"
Fonction qui applique un déplacement aux noeuds enfants de la table passée en paramètre qui sont sélectionnés\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Table contenant les noeuds auxquels on veut appliquer le déplacement\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurCreationLigne::visiter (\fBArbreRendu\fP * noeud)\fC [virtual]\fP"

.PP
Creation de poteau sur l'arbre de rendu\&. Fonction servant à donner l'accès au noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : l'arbre rendu contenant le noeud Table, entre autres\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurRotation::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"
Fonction servant à donner l'accès aux noeuds enfants sélectionnés de la table passée en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Les enfants de la table auxquels ont veut appliquer une rotation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSuppression::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"

.PP
Parcours du noeudTable\&. Fonction qui efface tous les enfants de la table passée en paramètre qui sont sélectionnés \&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : noued Table de laquelle on veut supprimer les enfants sélectionnés\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurRotation::visiter (\fBNoeudPoteau\fP * noeud)\fC [virtual]\fP"
Fonction qui modifie la position du noeud Poteau passé en paramètre selon la rotation effectuée\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Poteau auquel ont veut appliquer une rotation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSelection::visiter (\fBArbreRendu\fP * noeud)\fC [virtual]\fP"

.PP
Parcours du noeudTable\&. Fonction servant à donner l'accès au noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : l'arbre rendu contenant le noeud Table, entre autres\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAEchelle::visiter (\fBArbreRendu\fP * noeud)\fC [virtual]\fP"
Fonction servant à donner l'accès au noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : l'arbre rendu contenant le noeud Table, entre autres\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurCreationPoteau::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"

.PP
Creation de poteau sur la table\&. Fonction qui crée et ajoute un noeud Poteau au noeud Table passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Table auquel on veut ajouter le poteau\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "VisiteurCreationLigne::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"

.PP
Creation de poteau sur la table\&. Fonction qui crée et ajoute un noeud Ligne au noeud Table passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Table auquel on veut ajouter la ligne\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Fonction qui crée et ajoute un noeud Mur au noeud Table passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Table auquel on veut ajouter le mur\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurDuplication::visiter (\fBArbreRendu\fP * noeud)\fC [virtual]\fP"
Fonction servant à donner l'accès au noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : l'arbre rendu contenant le noeud Table, entre autres\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurRotation::visiter (\fBNoeudMur\fP * noeud)\fC [virtual]\fP"
Fonction qui modifie la position et l'angle de rotation du noeud Mur passé en paramètre selon la rotation effectuée\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Mur auquel ont veut appliquer une rotation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurRotation::visiter (\fBNoeudLigne\fP * noeud)\fC [virtual]\fP"
Fonction qui modifie la position et l'angle de rotation des enfants (segments) du noeud Ligne passé en paramètre selon la rotation effectuée\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Ligne auquel ont veut appliquer une rotation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurDuplication::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"
Fonction qui crée et ajoute un noeud Duplication au noeud Table passé en paramètre selon la sélection actuelle\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Table auquel on veut ajouter la duplication\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "VisiteurSelection::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"
Fonction qui sélectionne les objets du noeud Table passé en paramètre selon la position du curseur et selon l'état de la touche Ctrl\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Table auquel on veut appliquer la sélection\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&.
.RE
.PP
Fonction qui sélectionne le segment passé en paramètre selon la position du curseur et selon l'état de la touche Ctrl\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Table auquel on veut appliquer la sélection\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAEchelle::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"
Fonction servant à donner l'accès aux enfants de la table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Table contenant les enfants desquels on veut modifier le facteur de dimension\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAJourQuad::visiter (\fBArbreRendu\fP * noeud)\fC [virtual]\fP"
Fonction servant à donner l'accès au noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : l'arbre rendu contenant le noeud Table, entre autres\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurRotation::visiter (\fBNoeudDepart\fP * noeud)\fC [virtual]\fP"
Fonction qui modifie la position et l'angle de rotation du noeud Depart passé en paramètre selon la rotation effectuée\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Depart auquel ont veut appliquer une rotation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurDuplication::visiter (\fBNoeudPoteau\fP * noeud)\fC [virtual]\fP"
Fonction qui crée et ajoute un noeud Poteau au noeud Table passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Poteau que l'on veut ajouter\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAEchelle::visiter (\fBNoeudPoteau\fP * noeud)\fC [virtual]\fP"
Fonction modifiant le facteur de dimension du poteau passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Poteau duquel on veut modifier le facteur de dimension\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSelection::visiter (\fBNoeudPoteau\fP * noeud)\fC [virtual]\fP"
Fonction qui sélectionne le poteau passé en paramètre selon la position du curseur et selon l'état de la touche Ctrl\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Poteau auquel on veut appliquer la sélection\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAJourQuad::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"
Fonction servant à donner l'accès aux enfants du noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Table contenant les enfants auxquels on veut avoir accès\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSelection::visiter (\fBNoeudMur\fP * noeud)\fC [virtual]\fP"
Fonction qui sélectionne le mur passé en paramètre selon la position du curseur et selon l'état de la touche Ctrl\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Mur auquel on veut appliquer la sélection\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurVerificationQuad::visiter (\fBArbreRendu\fP * noeud)\fC [virtual]\fP"
Fonction servant à donner l'accès au noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : l'arbre rendu contenant le noeud Table, entre autres\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAJourQuad::visiter (\fBNoeudDuplication\fP * noeud)\fC [virtual]\fP"
Fonction qui met à jour le quadrilatère contenant les noeuds que l'on duplique\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Duplication contenant les noeuds que l'on veut dupliquer\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP
Mettre à jour le quad de la duplication\&.
.PP
Mettre à jour le quad des enfants\&. 
.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurDuplication::visiter (\fBNoeudMur\fP * noeud)\fC [virtual]\fP"
Fonction qui crée et ajoute un noeud Mur au noeud Table passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Mur que l'on veut ajouter\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAEchelle::visiter (\fBNoeudMur\fP * noeud)\fC [virtual]\fP"
Fonction modifiant le facteur de dimension du mur passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Mur duquel on veut modifier le facteur de dimension\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSelection::visiter (\fBNoeudLigne\fP * noeud)\fC [virtual]\fP"
Fonction qui sélectionne la ligne passée en paramètre selon la position du curseur et selon l'état de la touche Ctrl\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Ligne auquel on veut appliquer la sélection\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurDuplication::visiter (\fBNoeudLigne\fP * noeud)\fC [virtual]\fP"
Fonction qui crée et ajoute un noeud Ligne au noeud Table passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Ligne que l'on veut ajouter\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAJourQuad::visiter (\fBNoeudPoteau\fP * noeud)\fC [virtual]\fP"
Fonction qui met à jour le quadrilatère du poteau passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Poteau que l'on veut mettre à jour\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurVerificationQuad::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"
Fonction servant à donner l'accès aux enfants du noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Table contenant les enfants auxquels on veut avoir accès\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurDuplication::visiter (\fBNoeudSegment\fP * noeud)\fC [virtual]\fP"
Fonction qui crée et ajoute un noeud Segment au noeud Table passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Segment que l'on veut ajouter\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurVerificationQuad::visiter (\fBNoeudDuplication\fP * noeud)\fC [virtual]\fP"
Fonction servant à donner l'accès au nouveau noeud créée lors de la duplication\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Duplication contenant les enfants auxquels on veut avoir accès\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAJourQuad::visiter (\fBNoeudMur\fP * noeud)\fC [virtual]\fP"
Fonction qui met à jour le quadrilatère du mur passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Mur que l'on veut mettre à jour\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSelection::visiter (\fBNoeudDepart\fP * noeud)\fC [virtual]\fP"
Fonction qui sélectionne la flèche de départ passée en paramètre selon la position du curseur et selon l'état de la touche Ctrl\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Depart auquel on veut appliquer la sélection\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurDuplication::visiter (\fBNoeudJonction\fP * noeud)\fC [virtual]\fP"
Fonction qui crée et ajoute un noeud Jonction au noeud Table passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Jonction que l'on veut ajouter\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurVerificationQuad::visiter (\fBNoeudPoteau\fP * noeud)\fC [virtual]\fP"
Fonction qui vérifie que le poteau passé en paramètre se trouve dans les limites de la table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Poteau sur lequel on veut effectuer la vérication\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAJourQuad::visiter (\fBNoeudLigne\fP * noeud)\fC [virtual]\fP"
Fonction qui met à jour le quadrilatère de la ligne passée en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Ligne que l'on veut mettre à jour\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP
Mettre à jour le quad de la duplication\&.
.PP
Mettre à jour le quad des enfants\&. 
.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSelection::visiter (\fBNoeudSegment\fP * noeud)\fC [virtual]\fP"
Fonction virtuelle pour les classes dérivées donnant accès au noeud Segment passé en paramètre\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAJourQuad::visiter (\fBNoeudSegment\fP * noeud)\fC [virtual]\fP"
Fonction qui met à jour le quadrilatère du segment passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Segment que l'on veut mettre à jour\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurDuplication::visiter (\fBNoeudDuplication\fP * noeud)\fC [virtual]\fP"
Fonction qui crée et ajoute un noeud Duplication au noeud Table passé en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Duplication que l'on veut ajouter\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSelection::visiter (\fBNoeudJonction\fP * noeud)\fC [virtual]\fP"
Fonction qui sélectionne la jonction passée en paramètre selon la position du curseur et selon l'état de la touche Ctrl\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Jonction auquel on veut appliquer la sélection\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurVerificationQuad::visiter (\fBNoeudMur\fP * noeud)\fC [virtual]\fP"
Fonction qui vérifie que le mur passé en paramètre se trouve dans les limites de la table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Mur sur lequel on veut effectuer la vérication\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurVerificationQuad::visiter (\fBNoeudLigne\fP * noeud)\fC [virtual]\fP"
Fonction qui vérifie que la ligne passée en paramètre se trouve dans les limites de la table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Ligne sur lequel on veut effectuer la vérication\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAJourQuad::visiter (\fBNoeudJonction\fP * noeud)\fC [virtual]\fP"
Fonction qui met à jour le quadrilatère de la jonction passée en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Jonction que l'on veut mettre à jour\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurMiseAJourQuad::visiter (\fBNoeudDepart\fP * noeud)\fC [virtual]\fP"
Fonction qui met à jour le quadrilatère de la flèche de départ passée en paramètre\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Depart que l'on veut mettre à jour\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurVerificationQuad::visiter (\fBNoeudSegment\fP * noeud)\fC [virtual]\fP"
Fonction qui vérifie que le segment passé en paramètre se trouve dans les limites de la table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Segment sur lequel on veut effectuer la vérication\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSauvegarde::visiter (\fBArbreRendu\fP * noeud)\fC [virtual]\fP"

.PP
Sauvegarde en JSON de l'arbre de rendu\&. Sauvegarde la racine d'un arbre de rendu dans un fichier Json
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Pointeur vers la racine de l'arbre\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurVerificationQuad::visiter (\fBNoeudDepart\fP * noeud)\fC [virtual]\fP"
Fonction qui vérifie que la flèche de départ passée en paramètre se trouve dans les limites de la table\&.
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Le noeud Depart sur lequel on veut effectuer la vérication\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSauvegarde::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"

.PP
Sauvegarde en JSON d'un \fBNoeudTable\fP\&. Sauvegarde le noeud table d'un arbre de rendu dans un fichier Json
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Pointeur vers le noeud table de l'arbre\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSauvegarde::visiter (\fBNoeudPoteau\fP * noeud)\fC [virtual]\fP"

.PP
Sauvegarde en JSON d'un \fBNoeudPoteau\fP\&. Sauvegarde les noeuds poteaux d'un arbre de rendu dans un fichier Json
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Pointeur vers le noeud poteau de l'arbre\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSauvegarde::visiter (\fBNoeudMur\fP * noeud)\fC [virtual]\fP"

.PP
Sauvegarde en JSON d'un \fBNoeudMur\fP\&. Sauvegarde les noeuds murs d'un arbre de rendu dans un fichier Json
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Pointeur vers le noeud mur de l'arbre\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSauvegarde::visiter (\fBNoeudLigne\fP * noeud)\fC [virtual]\fP"

.PP
Sauvegarde en JSON d'un \fBNoeudLigne\fP\&. Sauvegarde les noeuds lignes d'un arbre de rendu dans un fichier Json
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Pointeur vers le noeud mur de l'arbre\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSauvegarde::visiter (\fBNoeudSegment\fP * noeud)\fC [virtual]\fP"

.PP
Sauvegarde en JSON d'un \fBNoeudSegment\fP\&. Sauvegarde les noeuds segments composant une ligne d'un arbre de rendu dans un fichier Json
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Pointeur vers le noeud segment de l'arbre\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurSauvegarde::visiter (\fBNoeudDepart\fP * noeud)\fC [virtual]\fP"

.PP
Sauvegarde en JSON d'un \fBNoeudDuplication\fP\&. Sauvegarde le noeud depart d'un arbre de rendu dans un fichier Json
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Pointeur vers le noeud depart de l'arbre\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurAbstrait::visiter (\fBArbreRendu\fP * noeud)\fC [virtual]\fP"
Fonction virtuelle pour les classes dérivées donnant accès à l'arbreRendu passé en paramètre\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBVisiteurSauvegarde\fP, \fBVisiteurVerificationQuad\fP, \fBVisiteurMiseAJourQuad\fP, \fBVisiteurDuplication\fP, \fBVisiteurMiseAEchelle\fP, \fBVisiteurSelection\fP, \fBVisiteurCreationLigne\fP, \fBVisiteurCreationMur\fP, \fBVisiteurCreationPoteau\fP, \fBVisiteurDeplacement\fP, and \fBVisiteurRotation\fP\&.
.SS "void VisiteurAbstrait::visiter (\fBNoeudTable\fP * noeud)\fC [virtual]\fP"
Fonction virtuelle pour les classes dérivées donnant accès au noeud Table passé en paramètre\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBVisiteurSauvegarde\fP, \fBVisiteurVerificationQuad\fP, \fBVisiteurMiseAJourQuad\fP, \fBVisiteurDuplication\fP, \fBVisiteurMiseAEchelle\fP, \fBVisiteurSelection\fP, \fBVisiteurCreationLigne\fP, \fBVisiteurCreationMur\fP, \fBVisiteurCreationPoteau\fP, \fBVisiteurSuppression\fP, \fBVisiteurDeplacement\fP, and \fBVisiteurRotation\fP\&.
.SS "void VisiteurAbstrait::visiter (\fBNoeudPoteau\fP * noeud)\fC [virtual]\fP"
Fonction virtuelle pour les classes dérivées donnant accès au noeud Poteau passé en paramètre\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBVisiteurSauvegarde\fP, \fBVisiteurVerificationQuad\fP, \fBVisiteurMiseAJourQuad\fP, \fBVisiteurDuplication\fP, \fBVisiteurMiseAEchelle\fP, \fBVisiteurSelection\fP, and \fBVisiteurRotation\fP\&.
.SS "void VisiteurSauvegarde::visiter (\fBNoeudJonction\fP * noeud)\fC [virtual]\fP"

.PP
Sauvegarde en JSON d'un \fBNoeudDuplication\fP\&. Sauvegarde les noeuds jonctions composant une ligne d'un arbre de rendu dans un fichier Json
.PP
\fBParameters:\fP
.RS 4
\fInoeud\fP : Pointeur vers le noeud jonction de l'arbre\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented from \fBVisiteurAbstrait\fP\&.
.SS "void VisiteurAbstrait::visiter (\fBNoeudMur\fP * noeud)\fC [virtual]\fP"
Fonction virtuelle pour les classes dérivées donnant accès au noeud Mur passé en paramètre\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBVisiteurSauvegarde\fP, \fBVisiteurVerificationQuad\fP, \fBVisiteurMiseAJourQuad\fP, \fBVisiteurDuplication\fP, \fBVisiteurMiseAEchelle\fP, \fBVisiteurSelection\fP, and \fBVisiteurRotation\fP\&.
.SS "void VisiteurAbstrait::visiter (\fBNoeudLigne\fP * noeud)\fC [virtual]\fP"
Fonction virtuelle pour les classes dérivées donnant accès au noeud Ligne passé en paramètre\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBVisiteurSauvegarde\fP, \fBVisiteurVerificationQuad\fP, \fBVisiteurMiseAJourQuad\fP, \fBVisiteurDuplication\fP, \fBVisiteurSelection\fP, and \fBVisiteurRotation\fP\&.
.SS "void VisiteurAbstrait::visiter (\fBNoeudSegment\fP * noeud)\fC [virtual]\fP"
Fonction virtuelle pour les classes dérivées donnant accès au noeud Segment passé en paramètre\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBVisiteurSauvegarde\fP, \fBVisiteurVerificationQuad\fP, \fBVisiteurMiseAJourQuad\fP, \fBVisiteurSelection\fP, and \fBVisiteurDuplication\fP\&.
.SS "void VisiteurAbstrait::visiter (\fBNoeudDuplication\fP * noeud)\fC [virtual]\fP"
Fonction virtuelle pour les classes dérivées donnant accès au noeud Duplication passé en paramètre\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBVisiteurDuplication\fP, \fBVisiteurVerificationQuad\fP, and \fBVisiteurMiseAJourQuad\fP\&.
.SS "void VisiteurAbstrait::visiter (\fBNoeudDepart\fP * noeud)\fC [virtual]\fP"
Fonction virtuelle pour les classes dérivées donnant accès au noeud Depart passé en paramètre\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBVisiteurSauvegarde\fP, \fBVisiteurVerificationQuad\fP, \fBVisiteurMiseAJourQuad\fP, \fBVisiteurSelection\fP, and \fBVisiteurRotation\fP\&.
.SS "void VisiteurAbstrait::visiter (\fBNoeudJonction\fP * noeud)\fC [virtual]\fP"
Fonction virtuelle pour les classes dérivées donnant accès au noeud Jonction passé en paramètre\&.
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.PP
Reimplemented in \fBVisiteurSauvegarde\fP, \fBVisiteurMiseAJourQuad\fP, \fBVisiteurSelection\fP, and \fBVisiteurDuplication\fP\&.
.SS "VisiteurAbstrait::VisiteurAbstrait ()"

.PP
Constructeur par défaut\&. Constructeur par défaut\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "VisiteurCreationLigne::VisiteurCreationLigne ()"

.PP
Constructeur par défaut\&. Constructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "VisiteurCreationMur::VisiteurCreationMur ()"

.PP
Constructeur par défaut\&. Constructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\&.\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "VisiteurCreationPoteau::VisiteurCreationPoteau ()"

.PP
Constructeur par défaut\&. Constructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "VisiteurDeplacement::VisiteurDeplacement ()"

.PP
Constructeur par défaut\&. Constructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "VisiteurDuplication::VisiteurDuplication ()"

.PP
Constructeur par défaut\&. Constructeur\&. Il initialise l'attribut centreSelection_ selon la sélection\&.
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "VisiteurMiseAEchelle::VisiteurMiseAEchelle ()"

.PP
Constructeur par défaut\&. Constructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "VisiteurMiseAJourQuad::VisiteurMiseAJourQuad ()"

.PP
Constructeur par défaut\&. Constructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "VisiteurRotation::VisiteurRotation ()"

.PP
Constructeur par défaut\&. Constructeur\&. Il calcul le centre de la sélection du noeud Table\&.
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "VisiteurSauvegarde::VisiteurSauvegarde ()"

.PP
Constructeur par défaut\&. Constructeur par défaut\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "VisiteurSelection::VisiteurSelection ()"

.PP
Constructeur par défaut\&. Constructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "VisiteurSuppression::VisiteurSuppression ()"

.PP
Constructeur par défaut\&. Constructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "VisiteurVerificationQuad::VisiteurVerificationQuad ()"

.PP
Constructeur par défaut\&. Constructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (constructeur)\&. 
.RE
.PP

.SS "public InterfaceGraphique\&.Window\&.Window ()\fC [inline]\fP"
Cette fonction initialize la fenetre et initialise la visibilitÃ© de ses composantes 
.SS "ArbreRendu::~ArbreRendu ()\fC [virtual]\fP"

.PP
Destructeur\&. Détruit les usines des noeuds de l'arbre\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "ArbreRenduINF2990::~ArbreRenduINF2990 ()\fC [virtual]\fP"

.PP
Destructeur\&. Ce destructeur ne fait rien pour le moment\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "EtatAbstrait::~EtatAbstrait ()\fC [virtual]\fP"
Destructeur par défault 
.SS "EtatCreationLigne::~EtatCreationLigne ()\fC [virtual]\fP"
Destructeur par défault 
.SS "EtatCreationMur::~EtatCreationMur ()\fC [virtual]\fP"
Destructeur par défault 
.SS "EtatCreationPoteau::~EtatCreationPoteau ()\fC [virtual]\fP"
Destructeur par défault 
.SS "EtatDeplacement::~EtatDeplacement ()\fC [virtual]\fP"
Destructeur par défault 
.SS "EtatDuplication::~EtatDuplication ()\fC [virtual]\fP"
Destructeur par défault 
.SS "EtatMiseAEchelle::~EtatMiseAEchelle ()\fC [virtual]\fP"
Destructeur par défault 
.SS "EtatRotation::~EtatRotation ()\fC [virtual]\fP"
Destructeur par défault 
.SS "EtatSelection::~EtatSelection ()\fC [virtual]\fP"
Destructeur par défault 
.SS "FacadeModele::~FacadeModele ()"

.PP
Destructeur\&. Ce destructeur libère les objets du modèle\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "ModeAbstrait::~ModeAbstrait ()\fC [virtual]\fP"
Destructeur (vide) par défaut de la classe \fBModeAbstrait\fP 
.SS "ModeConfigure::~ModeConfigure ()\fC [virtual]\fP"
Destructeur de la classe \fBModeConfigure\fP 
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "ModeEdition::~ModeEdition ()\fC [virtual]\fP"
Destructeur par défaut de la classe \fBModeEdition\fP
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "ModeMenuPrincipal::~ModeMenuPrincipal ()\fC [virtual]\fP"
Destructeur de la classe \fBModeMenuPrincipal\fP 
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "ModeSimulation::~ModeSimulation ()\fC [virtual]\fP"
Destructeur de la classe \fBModeSimulation\fP 
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "ModeTest::~ModeTest ()\fC [virtual]\fP"
Destructeur de la classe \fBModeTest\fP 
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "NoeudAbstrait::~NoeudAbstrait ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur vide déclaré virtuel pour les classes dérivées\&. La libération des afficheurs n'est pas la responsabilité de cette classe\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "NoeudComposite::~NoeudComposite ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur qui détruit tous les enfants du noeud\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "NoeudDepart::~NoeudDepart ()"

.PP
Destructeur\&. Ce destructeur désallouee la liste d'affichage du cube\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "NoeudDuplication::~NoeudDuplication ()"

.PP
Destructeur\&. Ce destructeur désallouee la liste d'affichage du cube\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "NoeudLigne::~NoeudLigne ()"

.PP
Destructeur\&. Ce destructeur désallouee la liste d'affichage du cube\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "NoeudMur::~NoeudMur ()"

.PP
Destructeur\&. Ce destructeur désallouee la liste d'affichage du cube\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "NoeudPoteau::~NoeudPoteau ()"

.PP
Destructeur\&. Ce destructeur désallouee la liste d'affichage du cube\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "NoeudRobot::~NoeudRobot ()"

.PP
Destructeur\&. Ce destructeur ne fait rien\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "NoeudSegment::~NoeudSegment ()"

.PP
Destructeur\&. Ce destructeur désallouee la liste d'affichage du cube\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "NoeudTable::~NoeudTable ()"

.PP
Destructeur\&. Ce destructeur désallouee la liste d'affichage du cube\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "VisiteurAbstrait::~VisiteurAbstrait ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur déclaré virtuel pour les classes dérivées\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. \fBNoeudDuplication\fP 
.RE
.PP

.SS "VisiteurCreationLigne::~VisiteurCreationLigne ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "VisiteurCreationMur::~VisiteurCreationMur ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\&.\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune\&. 
.RE
.PP

.SS "VisiteurCreationPoteau::~VisiteurCreationPoteau ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "VisiteurDeplacement::~VisiteurDeplacement ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "VisiteurDuplication::~VisiteurDuplication ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "VisiteurMiseAEchelle::~VisiteurMiseAEchelle ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "VisiteurMiseAJourQuad::~VisiteurMiseAJourQuad ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "VisiteurRotation::~VisiteurRotation ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "VisiteurSauvegarde::~VisiteurSauvegarde ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur déclaré virtuel pour les classes dérivées\&.
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "VisiteurSelection::~VisiteurSelection ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "VisiteurSuppression::~VisiteurSuppression ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SS "VisiteurVerificationQuad::~VisiteurVerificationQuad ()\fC [virtual]\fP"

.PP
Destructeur\&. Destructeur
.PP
\fBParameters:\fP
.RS 4
\fIAucun\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Aucune (destructeur)\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "int hauteur"
\fBInitial value:\fP
.PP
.nf
{
        FacadeModele::obtenirInstance()->obtenirVue()->redimensionnerFenetre(
            glm::ivec2{ 0, 0 },
            glm::ivec2{ largeur, hauteur }
        )
.fi
.SS "int longueur"
\fBInitial value:\fP
.PP
.nf
{
        strcpy_s(chemin, longueur, FacadeModele::obtenirInstance()->obtenirArbreRenduINF2990()->obtenirCheminFichierZoneDefaut()\&.c_str())
.fi
.SS "WPARAM LPARAM lParam"
\fBInitial value:\fP
.PP
.nf
{
        FacadeModele::obtenirInstance()->obtenirEtat()->assignerSymboleCurseur()
.fi
.SS "const std::string ArbreRenduINF2990::NOM_POTEAU { 'poteau' }\fC [static]\fP"

.PP
La chaîne représentant le type des poteaux\&. La chaîne représentant le type des poteeaux\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
