.TH "NoeudAbstrait" 3 "Mon Feb 15 2016" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NoeudAbstrait \- Classe de base du patron composite utilisée pour créer l'arbre de rendu\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <NoeudAbstrait\&.h>\fP
.PP
Inherited by \fBNoeudComposite\fP, \fBNoeudDepart\fP, \fBNoeudJonction\fP, \fBNoeudMur\fP, \fBNoeudPoteau\fP, and \fBNoeudSegment\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBNoeudAbstrait\fP (const std::string &type=std::string{''})"
.br
.RI "\fIConstructeur\&. \fP"
.ti -1c
.RI "virtual \fB~NoeudAbstrait\fP ()"
.br
.RI "\fIDestructeur\&. \fP"
.ti -1c
.RI "\fBNoeudAbstrait\fP * \fBobtenirParent\fP ()"
.br
.RI "\fIObtient le parent de ce noeud\&. \fP"
.ti -1c
.RI "const \fBNoeudAbstrait\fP * \fBobtenirParent\fP () const "
.br
.RI "\fIObtient le parent de ce noeud (version constante)\&. \fP"
.ti -1c
.RI "void \fBassignerParent\fP (\fBNoeudAbstrait\fP *parent)"
.br
.RI "\fIAssigne le parent de ce noeud\&. \fP"
.ti -1c
.RI "const glm::dvec3 & \fBobtenirPositionRelative\fP () const "
.br
.RI "\fIObtient la position relative du noeud\&. \fP"
.ti -1c
.RI "void \fBassignerPositionRelative\fP (const glm::dvec3 &positionRelative)"
.br
.RI "\fIAssigne la position relative du noeud\&. \fP"
.ti -1c
.RI "double \fBobtenirAngleRotation\fP () const "
.br
.RI "\fIObtient l'angle de rotation du noeud\&. \fP"
.ti -1c
.RI "void \fBassignerAngleRotation\fP (const double &angleRotation)"
.br
.RI "\fIAssigne l'angle de rotation du noeud par rapport au plan xy\&. \fP"
.ti -1c
.RI "double \fBobtenirFacteurMiseAEchelle\fP () const "
.br
.RI "\fIObtient le facteur de dimension du noeud\&. \fP"
.ti -1c
.RI "void \fBassignerFacteurMiseAEchelle\fP (const double &facteurDimension)"
.br
.RI "\fIAssigne le facteur de dimension\&. \fP"
.ti -1c
.RI "utilitaire::QuadEnglobant \fBobtenirQuadEnglobantCourant\fP () const "
.br
.RI "\fIObtient le quadrilatère englobant du noeud\&. \fP"
.ti -1c
.RI "void \fBassignerQuadEnglobantCourant\fP (const utilitaire::QuadEnglobant &quad)"
.br
.RI "\fIAssigne le quadrilatère englobant du noeud\&. \fP"
.ti -1c
.RI "utilitaire::QuadEnglobant \fBobtenirQuadEnglobantModele\fP () const "
.br
.RI "\fIObtenir la boite englobante du modèle\&. \fP"
.ti -1c
.RI "const std::string & \fBobtenirType\fP () const "
.br
.RI "\fIObtient le type du noeud\&. \fP"
.ti -1c
.RI "void \fBassignerAffiche\fP (bool affiche)"
.br
.RI "\fIÉcrit l'état de l'affichage du du noeud\&. \fP"
.ti -1c
.RI "bool \fBestAffiche\fP () const "
.br
.RI "\fIVérifie si le noeud se fait afficher\&. \fP"
.ti -1c
.RI "void \fBassignerSelection\fP (bool selectionne)"
.br
.RI "\fIÉcrit l'état de la sélection du noeud\&. \fP"
.ti -1c
.RI "bool \fBestSelectionne\fP () const "
.br
.RI "\fIVérifie si le noeud est sélectionné\&. \fP"
.ti -1c
.RI "void \fBassignerEstSelectionnable\fP (bool selectionnable)"
.br
.RI "\fIÉcrit si le noeud peut être sélectionné ou non\&. \fP"
.ti -1c
.RI "bool \fBestSelectionnable\fP () const "
.br
.RI "\fIVérifie si le noeud est sélectionnable\&. \fP"
.ti -1c
.RI "void \fBassignerEstEnregistrable\fP (bool enregistrable)"
.br
.RI "\fIÉcrit si le noeud peut être enregistré ou non\&. \fP"
.ti -1c
.RI "bool \fBestEnregistrable\fP () const "
.br
.RI "\fIVérifie si le noeud est enregistrable\&. \fP"
.ti -1c
.RI "bool \fBassignerEstDuplicable\fP (bool \fBestDuplicable\fP)"
.br
.RI "\fIÉcrit si le noeud peut être enregistré ou non\&. \fP"
.ti -1c
.RI "bool \fBestDuplicable\fP () const "
.br
.RI "\fIVérifie si l'objet peut être dupliqué\&. \fP"
.ti -1c
.RI "void \fBassignerObjetRendu\fP (modele::Modele3D const *modele, opengl::VBO const *liste)"
.br
.RI "\fIAssigne le modèle3D et la liste d'affichage du noeud courant\&. \fP"
.ti -1c
.RI "virtual unsigned int \fBcalculerProfondeur\fP () const "
.br
.RI "\fICalcule la profondeur de l'arbre sous le noeud courant\&. \fP"
.ti -1c
.RI "virtual void \fBvider\fP ()"
.br
.RI "\fIVide le noeud de ses enfants\&. \fP"
.ti -1c
.RI "virtual void \fBeffacer\fP (const \fBNoeudAbstrait\fP *noeud)"
.br
.RI "\fIEfface le noeud passé en paramètre\&. \fP"
.ti -1c
.RI "virtual const \fBNoeudAbstrait\fP * \fBchercher\fP (const std::string &typeNoeud) const "
.br
.RI "\fICherche un noeud par le type (sur un noeud constant)\&. \fP"
.ti -1c
.RI "virtual \fBNoeudAbstrait\fP * \fBchercher\fP (const std::string &typeNoeud)"
.br
.RI "\fICherche un noeud par le type\&. \fP"
.ti -1c
.RI "virtual const \fBNoeudAbstrait\fP * \fBchercher\fP (unsigned int indice) const "
.br
.RI "\fICherche un noeud enfant selon l'indice (sur un noeud constant)\&. \fP"
.ti -1c
.RI "virtual \fBNoeudAbstrait\fP * \fBchercher\fP (unsigned int indice)"
.br
.RI "\fICherche un noeud enfant selon l'indice\&. \fP"
.ti -1c
.RI "virtual bool \fBajouter\fP (std::shared_ptr< \fBNoeudAbstrait\fP > enfant)"
.br
.RI "\fIAjoute un noeud enfant\&. \fP"
.ti -1c
.RI "virtual unsigned int \fBobtenirNombreEnfants\fP () const "
.br
.RI "\fIObtient le nombre d'enfants du noeud\&. \fP"
.ti -1c
.RI "virtual void \fBinverserSelection\fP ()"
.br
.RI "\fIChanger la sélection du noeud\&. \fP"
.ti -1c
.RI "virtual void \fBeffacerSelection\fP ()"
.br
.RI "\fIEfface les enfants sélectionnés\&. \fP"
.ti -1c
.RI "virtual void \fBselectionnerTout\fP ()"
.br
.RI "\fISélectionne tous les enfants de même que le noeud\&. \fP"
.ti -1c
.RI "virtual void \fBdeselectionnerTout\fP ()"
.br
.RI "\fIDésélectionne tous les enfants de même que le noeud\&. \fP"
.ti -1c
.RI "virtual bool \fBselectionExiste\fP () const "
.br
.RI "\fIVérifier si le noeud ou un de ses enfants est sélectionné\&. \fP"
.ti -1c
.RI "virtual void \fBchangerModePolygones\fP (bool estForce)"
.br
.RI "\fIChange le mode d'affichage des polygones\&. \fP"
.ti -1c
.RI "virtual void \fBassignerModePolygones\fP (GLenum modePolygones)"
.br
.RI "\fIAssigne le mode d'affichage des polygones\&. \fP"
.ti -1c
.RI "virtual void \fBafficher\fP () const "
.br
.RI "\fIAffiche le noeud\&. \fP"
.ti -1c
.RI "virtual void \fBafficherConcret\fP () const "
.br
.RI "\fIAffiche le noeud de manière concrète\&. \fP"
.ti -1c
.RI "virtual void \fBanimer\fP (float dt)"
.br
.RI "\fIAnime le noeud\&. \fP"
.ti -1c
.RI "virtual void \fBaccepterVisiteur\fP (\fBVisiteurAbstrait\fP *visiteur)=0"
.br
.RI "\fIAccepter un visiteur\&. \fP"
.ti -1c
.RI "virtual modele::Modele3D const * \fBgetModele\fP ()"
.br
.RI "\fIRetourne le modèle\&. \fP"
.ti -1c
.RI "virtual bool \fBobtenirEnCreation\fP ()"
.br
.ti -1c
.RI "virtual void \fBassignerEnCreation\fP (bool enCreation)"
.br
.ti -1c
.RI "void \fBtoJson\fP (rapidjson::Writer< rapidjson::FileWriteStream > &writer)"
.br
.RI "\fIconvertit un noeud en JSON \fP"
.ti -1c
.RI "void \fBfromJson\fP (rapidjson::Value::ConstValueIterator noeudJSON)"
.br
.RI "\fIassigne les attributs d'un noeud à partir d'un JSON \fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBenCreation_\fP { false }"
.br
.RI "\fISi l'objet est en train de se faire créer\&. \fP"
.ti -1c
.RI "std::string \fBtype_\fP"
.br
.RI "\fIType du noeud\&. \fP"
.ti -1c
.RI "GLenum \fBmodePolygones_\fP { GL_FILL }"
.br
.RI "\fIMode d'affichage des polygones\&. \fP"
.ti -1c
.RI "glm::dvec3 \fBpositionRelative_\fP { 0, 0, 0 }"
.br
.RI "\fIPosition relative du noeud\&. \fP"
.ti -1c
.RI "double \fBangleRotation_\fP { 0 }"
.br
.RI "\fIAngle de rotation sur le plan xy\&. \fP"
.ti -1c
.RI "double \fBfacteurMiseAEchelle_\fP { 1 }"
.br
.RI "\fIFacteur de dimension sur le plan xy\&. \fP"
.ti -1c
.RI "utilitaire::QuadEnglobant \fBquadEnglobantCourant_\fP"
.br
.RI "\fIQuadrilatère englobant le noeud\&. \fP"
.ti -1c
.RI "utilitaire::QuadEnglobant \fBquadEnglobantModele_\fP"
.br
.RI "\fIQuadrilatère englobant le modèle\&. \fP"
.ti -1c
.RI "bool \fBaffiche_\fP { true }"
.br
.RI "\fIVrai si on doit afficher le noeud\&. \fP"
.ti -1c
.RI "bool \fBselectionne_\fP { false }"
.br
.RI "\fISélection du noeud\&. \fP"
.ti -1c
.RI "bool \fBselectionnable_\fP { true }"
.br
.RI "\fIVrai si le noeud est sélectionnable\&. \fP"
.ti -1c
.RI "bool \fBenregistrable_\fP { true }"
.br
.RI "\fIDétermine si l'objet peut être sauvegardé en XML\&. \fP"
.ti -1c
.RI "bool \fBestDuplicable_\fP { true }"
.br
.RI "\fIDétermine si l'objet peut être dupliqué \fP"
.ti -1c
.RI "\fBNoeudAbstrait\fP * \fBparent_\fP { nullptr }"
.br
.RI "\fIPointeur vers le parent\&. \fP"
.ti -1c
.RI "modele::Modele3D const * \fBmodele_\fP { nullptr }"
.br
.RI "\fIModèle 3D correspondant à ce noeud\&. \fP"
.ti -1c
.RI "opengl::VBO const * \fBvbo_\fP { nullptr }"
.br
.RI "\fIStorage pour le dessin du modèle\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Classe de base du patron composite utilisée pour créer l'arbre de rendu\&. 

Cette classe abstraite comprend l'interface de base que doivent implanter tous les noeuds pouvant être présent dans l'arbre de rendu\&.
.PP
\fBAuthor:\fP
.RS 4
DGI-2990 
.RE
.PP
\fBDate:\fP
.RS 4
2007-01-24 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
